(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{317:function(t,s,a){t.exports=a.p+"assets/img/react-old-lifecycle.8495df2e.png"},318:function(t,s,a){t.exports=a.p+"assets/img/react-new-lifecycle.89e2bedb.png"},319:function(t,s,a){t.exports=a.p+"assets/img/react_new_lifecycle_usage.6bfd8043.jpg"},320:function(t,s,a){t.exports=a.p+"assets/img/react_diff.6a6811a9.jpg"},359:function(t,s,a){"use strict";a.r(s);var n=a(53),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"react"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),n("h2",{attrs:{id:"fiber"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[t._v("#")]),t._v(" Fiber")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/5c92f499f265da612647b754",target:"_blank",rel:"noopener noreferrer"}},[t._v("原文"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("产生原因：")]),t._v(" "),n("p",[t._v("随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，\n导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是"),n("code",[t._v("同步阻塞")]),t._v("。\n在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用"),n("code",[t._v("同步递归")]),t._v("的方式进行遍历渲染，而这个过程最大的问题就是无法"),n("code",[t._v("暂停和恢复")])]),t._v(" "),n("p",[t._v("解决方法：")]),t._v(" "),n("p",[t._v("解决同步阻塞的方法，通常有两种: "),n("code",[t._v("异步")]),t._v("与"),n("code",[t._v("任务分割")]),t._v("。而 React Fiber 便是为了实现任务分割而诞生的")]),t._v(" "),n("p",[t._v("简述：")]),t._v(" "),n("ul",[n("li",[t._v("在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的"),n("code",[t._v("单链表树遍历算法")]),t._v("。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启")]),t._v(" "),n("li",[t._v("这里我理解为是一种"),n("code",[t._v("任务分割调度算法")]),t._v("，主要是 将原先同步更新渲染的任务分割成一个个独立的"),n("code",[t._v("小任务单位")]),t._v("，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制")])]),t._v(" "),n("p",[t._v("核心：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fiber")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("instance")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("instance "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" instance\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向第一个 child 节点")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("child "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" child\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向父节点")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("return "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" parent\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向第一个兄弟节点")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sibling "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" previous\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("ul",[n("li",[n("p",[n("strong",[t._v("链表树遍历算法")]),t._v(": 通过"),n("code",[t._v("节点保存与映射")]),t._v("，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提")]),t._v(" "),n("ol",[n("li",[t._v("首先通过不断遍历子节点，到树末尾")]),t._v(" "),n("li",[t._v("开始通过 sibling 遍历兄弟节点")]),t._v(" "),n("li",[t._v("return 返回父节点，继续执行2")]),t._v(" "),n("li",[t._v("直到 root 节点后，跳出遍历")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("任务分割")]),t._v("，React 中的渲染更新可以分成两个阶段:")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("reconciliation")]),t._v("阶段: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对")]),t._v(" "),n("li",[n("strong",[t._v("Commit")]),t._v("阶段: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，\n而导致数据更新和 UI 不一致的情况")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("分散执行")]),t._v(": 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，\n而实现的关键是两个新API: "),n("code",[t._v("requestIdleCallback")]),t._v("与 "),n("code",[t._v("requestAnimationFrame")])]),t._v(" "),n("ul",[n("li",[n("p",[t._v("低优先级的任务交给"),n("code",[t._v("requestIdleCallback")]),t._v("处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，\n而且拥有 deadline 参数，限制执行事件，以继续切分任务")])]),t._v(" "),n("li",[n("p",[t._v("高优先级的任务交给"),n("code",[t._v("requestAnimationFrame")]),t._v("处理")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 类似于这样的方式")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("requestIdleCallback")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("deadline")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当有空闲时间时，我们执行一个组件渲染；")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把任务塞到一个个碎片时间中去；")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("deadline"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("timeRemaining")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" deadline"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("didTimeout"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" nextComponent"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        nextComponent "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("performWork")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nextComponent"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("优先级策略")]),t._v(":文本框输入 > 本次调度结束需完成的任务 > 动画过渡 > 交互反馈 > 数据更新 > 不会显示但以防将来会显示的任务")])])]),t._v(" "),n("h2",{attrs:{id:"生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),n("p",[t._v("v16.3版本之前的生命周期")]),t._v(" "),n("p",[n("img",{attrs:{src:a(317),alt:"react生命周期"}})]),t._v(" "),n("p",[t._v("在v16.3中，React对生命周期有了新的"),n("code",[t._v("变动建议")])]),t._v(" "),n("p",[n("img",{attrs:{src:a(318),alt:"react生命周期"}})]),t._v(" "),n("ul",[n("li",[t._v("使用"),n("code",[t._v("getDerivedStateFromProps")]),t._v("替换"),n("code",[t._v("componentWillMount")])]),t._v(" "),n("li",[t._v("使用"),n("code",[t._v("getSnapshotBeforeUpdate")]),t._v("替换"),n("code",[t._v("componentWillUpdate")])]),t._v(" "),n("li",[t._v("避免使用"),n("code",[t._v("componentWillReceiveProps")])])]),t._v(" "),n("p",[t._v("其实该变动的原因，正是由于上述提到的 Fiber。首先，从上面我们知道 React 可以分成 reconciliation 与 commit 两个阶段，对应的生命周期如下:")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("reconciliation")]),t._v(" "),n("ul",[n("li",[t._v("componentWillMount")]),t._v(" "),n("li",[t._v("componentWillReceiveProps")]),t._v(" "),n("li",[t._v("shouldComponentUpdate")]),t._v(" "),n("li",[t._v("componentWillUpdate")])])]),t._v(" "),n("li",[n("p",[t._v("commit")]),t._v(" "),n("ul",[n("li",[t._v("componentDidMount")]),t._v(" "),n("li",[t._v("componentDidUpdate")]),t._v(" "),n("li",[t._v("componentWillUnmount")])])])]),t._v(" "),n("p",[t._v("在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被"),n("code",[t._v("多次调用")]),t._v("的情况，产生一些意外错误")]),t._v(" "),n("p",[t._v("新的生命周期如下：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Component")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 替换 `componentWillReceiveProps` ，")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化和 update 时被调用")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 静态函数，无法使用 this")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getDerivedStateFromProps")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("nextProps"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" prevState")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  \n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 判断是否需要更新组件")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可以用于组件性能优化")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldComponentUpdate")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("nextProps"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nextState")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  \n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组件被挂载后触发")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidMount")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  \n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 替换 componentWillUpdate")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可以在更新之前获取最新 dom 数据")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getSnapshotBeforeUpdate")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  \n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组件更新后调用")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidUpdate")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  \n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组件即将销毁")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentWillUnmount")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  \n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组件已销毁")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidUnMount")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h3",{attrs:{id:"新的生命周期用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#新的生命周期用法"}},[t._v("#")]),t._v(" 新的生命周期用法")]),t._v(" "),n("p",[n("img",{attrs:{src:a(319),alt:"新生命周期"}})]),t._v(" "),n("h2",{attrs:{id:"setstate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[t._v("#")]),t._v(" setState")]),t._v(" "),n("h3",{attrs:{id:"事务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[t._v("#")]),t._v(" 事务")]),t._v(" "),n("p",[t._v("在了解setState之前，我们先来简单了解下 React 一个包装结构: "),n("strong",[t._v("Transaction")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("事务")]),t._v("：\n"),n("ul",[n("li",[t._v("是 React 中的一个调用结构，用于包装一个方法，结构为: "),n("strong",[t._v("initialize - perform(method) - close")]),t._v("。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作")])])])]),t._v(" "),n("h3",{attrs:{id:"setstate方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#setstate方法"}},[t._v("#")]),t._v(" setState方法")]),t._v(" "),n("p",[t._v("React 中用于修改状态，更新视图。它具有以下特点:")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("异步与同步")]),t._v("： setState并不是单纯的异步或同步，这其实与调用时的环境相关")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("在"),n("strong",[t._v("合成事件")]),t._v("和**生命周期钩子(除 componentDidUpdate)**中，setState是“异步”的")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("原因：因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新")]),t._v(" "),n("ul",[n("li",[t._v("在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行")]),t._v(" "),n("li",[t._v("在合成事件中，React 是基于"),n("strong",[t._v("事务流完成的事件委托机制")]),t._v("实现，也是处于事务流中")])])]),t._v(" "),n("li",[n("p",[t._v("问题：无法在setState后马上从this.state上获取更新后的值")])]),t._v(" "),n("li",[n("p",[t._v("解决：如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值")])])])]),t._v(" "),n("li",[n("p",[t._v("在"),n("strong",[t._v("原生事件")]),t._v("和"),n("strong",[t._v("setTimout")]),t._v("中，setState是同步的，可以马上获得更新后的值")]),t._v(" "),n("ul",[n("li",[t._v("原因：原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步")])])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("批量更新")]),t._v("：在"),n("strong",[t._v("合成事件")]),t._v("和"),n("strong",[t._v("生命周期钩子")]),t._v("中，setState更新队列时，存储的是"),n("strong",[t._v("合并状态")]),t._v("(Object.assign)。\n因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新")])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("函数式")]),t._v("：于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，\n例如this.setState((state, props) => newState)")]),t._v(" "),n("ul",[n("li",[t._v("使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用。")])])])]),t._v(" "),n("h2",{attrs:{id:"diff"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#diff"}},[t._v("#")]),t._v(" diff")]),t._v(" "),n("p",[n("img",{attrs:{src:a(320),alt:"diff"}})])])}),[],!1,null,null,null);s.default=e.exports}}]);