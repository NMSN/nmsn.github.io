<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | NMSN</title>
    <meta name="description" content="Somebody has to win, so why not be me?">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/favicon.ico">
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?6594ba1364804631f0a8fd4452766fed";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script aysnc="true" src="https://www.googletagmanager.com/gtag/js?id=UA-127895888-1"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-127895888-1');
  </script>
    
    <link rel="preload" href="/assets/css/0.styles.f2223a60.css" as="style"><link rel="preload" href="/assets/js/app.a53673d4.js" as="script"><link rel="preload" href="/assets/js/2.666a23ec.js" as="script"><link rel="preload" href="/assets/js/5.40f9de20.js" as="script"><link rel="prefetch" href="/assets/js/10.cf7ae202.js"><link rel="prefetch" href="/assets/js/11.673ef652.js"><link rel="prefetch" href="/assets/js/12.c6c3488c.js"><link rel="prefetch" href="/assets/js/13.ebd3f958.js"><link rel="prefetch" href="/assets/js/14.a0a760d1.js"><link rel="prefetch" href="/assets/js/15.1a56fe6a.js"><link rel="prefetch" href="/assets/js/16.e7ac4b92.js"><link rel="prefetch" href="/assets/js/17.dbc9c8b2.js"><link rel="prefetch" href="/assets/js/18.ba2e30af.js"><link rel="prefetch" href="/assets/js/19.5872035c.js"><link rel="prefetch" href="/assets/js/20.9ed47cbc.js"><link rel="prefetch" href="/assets/js/21.9f47df3f.js"><link rel="prefetch" href="/assets/js/22.234954b8.js"><link rel="prefetch" href="/assets/js/23.07154985.js"><link rel="prefetch" href="/assets/js/24.85f3bf7b.js"><link rel="prefetch" href="/assets/js/25.aa36e96e.js"><link rel="prefetch" href="/assets/js/26.3bcd3ec8.js"><link rel="prefetch" href="/assets/js/27.58e5f5c5.js"><link rel="prefetch" href="/assets/js/28.4b128bb6.js"><link rel="prefetch" href="/assets/js/29.a9baeed0.js"><link rel="prefetch" href="/assets/js/3.5160e53d.js"><link rel="prefetch" href="/assets/js/30.3fef4250.js"><link rel="prefetch" href="/assets/js/31.f1675012.js"><link rel="prefetch" href="/assets/js/32.931a98e2.js"><link rel="prefetch" href="/assets/js/33.dd728fc8.js"><link rel="prefetch" href="/assets/js/34.aaef5604.js"><link rel="prefetch" href="/assets/js/35.d0a287db.js"><link rel="prefetch" href="/assets/js/36.104bdfff.js"><link rel="prefetch" href="/assets/js/37.1f505248.js"><link rel="prefetch" href="/assets/js/38.1e3926e7.js"><link rel="prefetch" href="/assets/js/39.9f5ed871.js"><link rel="prefetch" href="/assets/js/4.a971fc9a.js"><link rel="prefetch" href="/assets/js/40.6cfca759.js"><link rel="prefetch" href="/assets/js/41.8d01a67f.js"><link rel="prefetch" href="/assets/js/42.1320285f.js"><link rel="prefetch" href="/assets/js/43.242608e6.js"><link rel="prefetch" href="/assets/js/44.cccc62fb.js"><link rel="prefetch" href="/assets/js/45.9731a79a.js"><link rel="prefetch" href="/assets/js/46.5185b44c.js"><link rel="prefetch" href="/assets/js/47.5c37825a.js"><link rel="prefetch" href="/assets/js/48.71132d30.js"><link rel="prefetch" href="/assets/js/49.45a52e60.js"><link rel="prefetch" href="/assets/js/6.ae30d62e.js"><link rel="prefetch" href="/assets/js/7.be7e78a6.js"><link rel="prefetch" href="/assets/js/8.100847ee.js"><link rel="prefetch" href="/assets/js/9.3e725b23.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f2223a60.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">NMSN</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/tech/" class="nav-link">
  快查总结
</a></div><div class="nav-item"><a href="/excerpt/" class="nav-link">
  摘录
</a></div><div class="nav-item"><a href="/interviewQuestions/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/readingNotes/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/work/" class="nav-link">
  工作总结
</a></div> <a href="https://github.com/nmsn" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/tech/" class="nav-link">
  快查总结
</a></div><div class="nav-item"><a href="/excerpt/" class="nav-link">
  摘录
</a></div><div class="nav-item"><a href="/interviewQuestions/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/readingNotes/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/work/" class="nav-link">
  工作总结
</a></div> <a href="https://github.com/nmsn" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interviewQuestions/HTML.html" class="sidebar-link">HTML</a></li><li><a href="/interviewQuestions/CSS.html" class="sidebar-link">CSS</a></li><li><a href="/interviewQuestions/JS.html" class="sidebar-link">JS</a></li><li><a href="/interviewQuestions/Network.html" class="sidebar-link">网络</a></li><li><a href="/interviewQuestions/浏览器.html" class="sidebar-link">浏览器</a></li><li><a href="/interviewQuestions/React.html" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#fiber" class="sidebar-link">Fiber</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#setstate" class="sidebar-link">setState</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#diff" class="sidebar-link">diff</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#render-props" class="sidebar-link">Render Props</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#hoc" class="sidebar-link">HOC</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#mixin、hoc、render-props、react-hooks的优劣如何" class="sidebar-link">mixin、HOC、render props、react-hooks的优劣如何</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#react-redux是如何工作的" class="sidebar-link">react-redux是如何工作的</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#redux异步中间件之间的优劣" class="sidebar-link">redux异步中间件之间的优劣</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#redux与mobx的区别" class="sidebar-link">redux与mobx的区别</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#为什么需要virtual-dom" class="sidebar-link">为什么需要Virtual DOM</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#react-hooks" class="sidebar-link">React Hooks</a></li></ul></li><li><a href="/interviewQuestions/Vue.html" class="sidebar-link">Vue</a></li><li><a href="/interviewQuestions/Webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/interviewQuestions/设计模式.html" class="sidebar-link">设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" class="header-anchor">#</a> React</h1> <h2 id="fiber"><a href="#fiber" class="header-anchor">#</a> Fiber</h2> <p><a href="https://juejin.im/post/5c92f499f265da612647b754" target="_blank" rel="noopener noreferrer">原文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>产生原因：</p> <p>随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，
导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是<code>同步阻塞</code>。
在之前的<code>reconcilation</code>调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用<code>同步递归</code>的方式进行遍历渲染，而这个过程最大的问题就是无法<code>暂停和恢复</code></p> <p>解决方法：</p> <p>解决同步阻塞的方法，通常有两种: <code>异步</code>与<code>任务分割</code>。而 React Fiber 便是为了实现任务分割而诞生的</p> <p>简述：</p> <ul><li>在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的<code>单链表树遍历算法</code>。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启</li> <li>这里我理解为是一种<code>任务分割调度算法</code>，主要是 将原先同步更新渲染的任务分割成一个个独立的<code>小任务单位</code>，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制</li></ul> <p>核心：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Fiber</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">instance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance
    <span class="token comment">// 指向第一个 child 节点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> child
    <span class="token comment">// 指向父节点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> parent
    <span class="token comment">// 指向第一个兄弟节点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> previous
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p><strong>链表树遍历算法</strong>: 通过<code>节点保存与映射</code>，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提</p> <ol><li>首先通过不断遍历子节点，到树末尾</li> <li>开始通过 sibling 遍历兄弟节点</li> <li>return 返回父节点，继续执行2</li> <li>直到 root 节点后，跳出遍历</li></ol></li> <li><p><strong>任务分割</strong>，React 中的渲染更新可以分成两个阶段:</p> <ul><li><strong>reconciliation</strong>阶段: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对</li> <li><strong>Commit</strong>阶段: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，
而导致数据更新和 UI 不一致的情况</li></ul></li> <li><p><strong>分散执行</strong>: 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，
而实现的关键是两个新API: <code>requestIdleCallback</code>与 <code>requestAnimationFrame</code></p> <ul><li><p>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，
而且拥有 deadline 参数，限制执行事件，以继续切分任务</p></li> <li><p>高优先级的任务交给<code>requestAnimationFrame</code>处理</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 类似于这样的方式</span>
<span class="token function">requestIdleCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当有空闲时间时，我们执行一个组件渲染；</span>
    <span class="token comment">// 把任务塞到一个个碎片时间中去；</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> deadline<span class="token punctuation">.</span>didTimeout<span class="token punctuation">)</span>
      <span class="token operator">&amp;&amp;</span> nextComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nextComponent <span class="token operator">=</span> <span class="token function">performWork</span><span class="token punctuation">(</span>nextComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p><strong>优先级策略</strong>:文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</p></li></ul> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p>v16.3版本之前的生命周期</p> <p><img src="/assets/img/react-old-lifecycle.8495df2e.png" alt="react生命周期"></p> <p><img src="/assets/img/react-old-lifecycle2.7ea35f47.png" alt="react生命周期"></p> <p>在v16.3中，React对生命周期有了新的<code>变动建议</code></p> <p><img src="/assets/img/react-new-lifecycle.89e2bedb.png" alt="react生命周期"></p> <ul><li>使用<code>getDerivedStateFromProps</code>替换<code>componentWillMount</code></li> <li>使用<code>getSnapshotBeforeUpdate</code>替换<code>componentWillUpdate</code></li> <li>避免使用<code>componentWillReceiveProps</code></li></ul> <p>在v16.4中，修正了getDerivedStateFromProps</p> <p><img src="/assets/img/react-new-lifecycle-16.4.967af23b.png" alt="react生命周期"></p> <p>其实该变动的原因，正是由于上述提到的 Fiber。首先，从上面我们知道 React 可以分成 reconciliation 与 commit 两个阶段，对应的生命周期如下:</p> <ul><li><p>reconciliation</p> <ul><li>componentWillMount</li> <li>componentWillReceiveProps</li> <li>shouldComponentUpdate</li> <li>componentWillUpdate</li></ul></li> <li><p>commit</p> <ul><li>componentDidMount</li> <li>componentDidUpdate</li> <li>componentWillUnmount</li></ul></li></ul> <p>在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被<code>多次调用</code>的情况，产生一些意外错误</p> <p>新的生命周期如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// 替换 `componentWillReceiveProps` ，</span>
  <span class="token comment">// 初始化和 update 时被调用</span>
  <span class="token comment">// 静态函数，无法使用 this</span>
  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 判断是否需要更新组件</span>
  <span class="token comment">// 可以用于组件性能优化</span>
  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 组件被挂载后触发</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 替换 componentWillUpdate</span>
  <span class="token comment">// 可以在更新之前获取最新 dom 数据</span>
  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 组件更新后调用</span>
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 组件即将销毁</span>
  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 组件已销毁</span>
  <span class="token function">componentDidUnMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="新的生命周期用法"><a href="#新的生命周期用法" class="header-anchor">#</a> 新的生命周期用法</h3> <p><img src="/assets/img/react_new_lifecycle_usage.6bfd8043.jpg" alt="新生命周期"></p> <h2 id="setstate"><a href="#setstate" class="header-anchor">#</a> setState</h2> <h3 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h3> <p>在了解setState之前，我们先来简单了解下 React 一个包装结构: <strong>Transaction</strong>:</p> <ul><li><strong>事务</strong>：
<ul><li>是 React 中的一个调用结构，用于包装一个方法，结构为: <strong>initialize - perform(method) - close</strong>。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作</li></ul></li></ul> <h3 id="setstate方法"><a href="#setstate方法" class="header-anchor">#</a> setState方法</h3> <p>React 中用于修改状态，更新视图。它具有以下特点:</p> <ul><li><p><strong>异步与同步</strong>： setState并不是单纯的异步或同步，这其实与调用时的环境相关</p> <ul><li><p>在<strong>合成事件</strong>和**生命周期钩子(除 componentDidUpdate)**中，setState是“异步”的</p> <ul><li><p>原因：因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新</p> <ul><li>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行</li> <li>在合成事件中，React 是基于<strong>事务流完成的事件委托机制</strong>实现，也是处于事务流中</li></ul></li> <li><p>问题：无法在setState后马上从this.state上获取更新后的值</p></li> <li><p>解决：如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值</p></li></ul></li> <li><p>在<strong>原生事件</strong>和<strong>setTimout</strong>中，setState是同步的，可以马上获得更新后的值</p> <ul><li>原因：原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步</li></ul></li></ul></li> <li><p><strong>批量更新</strong>：在<strong>合成事件</strong>和<strong>生命周期钩子</strong>中，setState更新队列时，存储的是<strong>合并状态</strong>(Object.assign)。
因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新</p></li> <li><p><strong>函数式</strong>：于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，
例如this.setState((state, props) =&gt; newState)</p> <ul><li>使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用。</li></ul></li></ul> <h2 id="diff"><a href="#diff" class="header-anchor">#</a> diff</h2> <p><img src="/assets/img/react_diff.6a6811a9.jpg" alt="diff"></p> <h2 id="render-props"><a href="#render-props" class="header-anchor">#</a> Render Props</h2> <p>The Render Props是一种在不重复代码的情况下共享组件间功能的方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>DataProvider render<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello <span class="token punctuation">{</span>data<span class="token punctuation">.</span>target<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><p>通过使用prop来定义呈现的内容，组件只是注入功能，而不需要知道它如何应用于UI。render prop 模式意味着用户通过定义单独组件来传递prop方法，来指示共享组件应该返回的内容。</p> <p>Render Props 的核心思想是，通过一个函数将class组件的state作为props传递给纯函数组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> SharedComponent <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> SharedComponent<span class="token punctuation">;</span>
</code></pre></div><h2 id="hoc"><a href="#hoc" class="header-anchor">#</a> HOC</h2> <blockquote><p>A higher-order component is a function that takes a component and returns a new component.</p></blockquote> <p>实现高阶组件的方式有以下两种:</p> <ul><li>属性代理(Props Proxy)</li> <li>反向继承(Inheritance Inversion)</li></ul> <h3 id="属性代理"><a href="#属性代理" class="header-anchor">#</a> 属性代理</h3> <h4 id="操作props"><a href="#操作props" class="header-anchor">#</a> 操作props</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">HOC</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword">class</span> <span class="token class-name">WrapperComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span>
              name<span class="token operator">:</span> <span class="token string">'HOC'</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent
              <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span>
          <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>在上面的例子中，我们为被包裹组件(WrappedComponent)新增加了固定的name属性，因此WrappedComponent组件中就会多一个name的属性。</p> <h4 id="获得refs的引用"><a href="#获得refs的引用" class="header-anchor">#</a> 获得refs的引用</h4> <p>我们在属性代理中，可以轻松的拿到被包裹的组件的实例引用(ref)，例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'React'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">HOC</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token keyword">class</span> <span class="token class-name">wrapperComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
        <span class="token function">storeRef</span><span class="token punctuation">(</span><span class="token parameter">ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> ref<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent
                <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span>
                ref <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>storeRef<span class="token punctuation">}</span>
            <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>面的例子中，wrapperComponent渲染接受后，我们就可以拿到WrappedComponent组件的实例，进而实现调用实例方法的操作(当然这样会在一定程度上是反模式的，不是非常的推荐)。</p> <h4 id="抽象state"><a href="#抽象state" class="header-anchor">#</a> 抽象state</h4> <p>属性代理的情况下，我们可以将被包裹组件(WrappedComponent)中的状态提到包裹组件中，一个常见的例子就是实现不受控组件到受控的组件的转变</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">WrappedComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>input name<span class="token operator">=</span><span class="token string">&quot;name&quot;</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">HOC</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token keyword">class</span> <span class="token class-name">extends</span> Component <span class="token punctuation">{</span>
        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
                name<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>

            <span class="token keyword">this</span><span class="token punctuation">.</span>onNameChange <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onNameChange</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">onNameChange</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                name<span class="token operator">:</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span>
                    value<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
                    onChange<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onNameChange
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>newProps<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>上面的例子中通过高阶组件，我们将不受控组件(WrappedComponent)成功的转变为受控组件</p> <h3 id="反向继承"><a href="#反向继承" class="header-anchor">#</a> 反向继承</h3> <p>反向继承是指返回的组件去继承之前的组件(这里都用WrappedComponent代指)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">HOC</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword">class</span> <span class="token class-name">extends</span> WrappedComponent <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>我们可以看见返回的组件确实都继承自WrappedComponent,那么所有的调用将是反向调用的(例如:super.render())，这也就是为什么叫做反向继承。</p> <h4 id="渲染劫持"><a href="#渲染劫持" class="header-anchor">#</a> 渲染劫持</h4> <p>渲染劫持是指我们可以有意识地控制WrappedComponent的渲染过程，从而控制渲染控制的结果。例如我们可以根据部分参数去决定是否渲染组件:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">HOC</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword">class</span> <span class="token class-name">extends</span> WrappedComponent <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>isRender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>甚至我们可以修改修改render的结果:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//例子来源于《深入React技术栈》</span>

<span class="token keyword">const</span> <span class="token function-variable function">HOC</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token keyword">class</span> <span class="token class-name">extends</span> WrappedComponent <span class="token punctuation">{</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> elementsTree <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementsTree <span class="token operator">&amp;&amp;</span> elementsTree<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'input'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                newProps <span class="token operator">=</span> <span class="token punctuation">{</span>value<span class="token operator">:</span> <span class="token string">'may the force be with you'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">const</span> props <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> elementsTree<span class="token punctuation">.</span>props<span class="token punctuation">,</span> newProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">const</span> newElementsTree <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">cloneElement</span><span class="token punctuation">(</span>elementsTree<span class="token punctuation">,</span> props<span class="token punctuation">,</span> elementsTree<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> newElementsTree<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">WrappedComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>input value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'Hello World'</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token constant">HOC</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span>
<span class="token comment">//实际显示的效果是input的值为&quot;may the force be with you&quot;</span>
</code></pre></div><h3 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h3> <ul><li>React 高阶组件(HOC)入门指南：<a href="https://github.com/MrErHu/blog/issues/4" target="_blank" rel="noopener noreferrer">https://github.com/MrErHu/blog/issues/4<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="mixin、hoc、render-props、react-hooks的优劣如何"><a href="#mixin、hoc、render-props、react-hooks的优劣如何" class="header-anchor">#</a> mixin、HOC、render props、react-hooks的优劣如何</h2> <h3 id="mixin的缺陷"><a href="#mixin的缺陷" class="header-anchor">#</a> Mixin的缺陷</h3> <ul><li>组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知道这种依赖关系）</li> <li>多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）</li> <li>Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your application, the harder it is to reason about it.），导致复杂度剧增</li> <li>隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：
<ul><li>难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互影响</li> <li>组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它</li> <li>Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个 Mixin 的输入输出</li></ul></li></ul> <h3 id="hoc相比mixin的优势"><a href="#hoc相比mixin的优势" class="header-anchor">#</a> HOC相比Mixin的优势</h3> <ul><li>HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突和互相干扰,这就降低了耦合度</li> <li>不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂度。</li></ul> <h3 id="hoc的缺陷"><a href="#hoc的缺陷" class="header-anchor">#</a> HOC的缺陷</h3> <ul><li>扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这个问题</li> <li>Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题</li> <li>Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本</li> <li>命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性</li> <li>不可见性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于你是黑盒</li></ul> <h3 id="render-props优点"><a href="#render-props优点" class="header-anchor">#</a> Render Props优点</h3> <p>上述HOC的缺点Render Props都可以解决</p> <h3 id="render-props缺陷"><a href="#render-props缺陷" class="header-anchor">#</a> Render Props缺陷</h3> <ul><li>使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无法做到如此简单</li> <li>嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套</li></ul> <h3 id="react-hooks优点"><a href="#react-hooks优点" class="header-anchor">#</a> React Hooks优点</h3> <ul><li>简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁</li> <li>解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦</li> <li>组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千</li> <li>函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
<ul><li>this 指向容易错误</li> <li>分割在不同声明周期中的逻辑使得代码难以理解和维护</li> <li>代码复用成本高（高阶组件容易使代码量剧增）</li></ul></li></ul> <h3 id="react-hooks缺陷"><a href="#react-hooks缺陷" class="header-anchor">#</a> React Hooks缺陷</h3> <ul><li>额外的学习成本（Functional Component 与 Class Component 之间的困惑）</li> <li>写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本</li> <li>破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和state，每次render()都要重新创建事件处函数）</li> <li>在闭包场景可能会引用到旧的state、props值</li> <li>内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）</li> <li>React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针对 props change）</li></ul> <h2 id="react-redux是如何工作的"><a href="#react-redux是如何工作的" class="header-anchor">#</a> react-redux是如何工作的</h2> <ul><li>Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store</li> <li>connect: 负责连接React和Redux
<ul><li>获取state: connect通过context获取Provider中的store，通过store.getState()获取整个store tree 上所有state</li> <li>包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件WrappedComponent，并把connect中传入的mapStateToProps, mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给WrappedComponent</li> <li>监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组件的重新渲染</li></ul></li></ul> <p><img src="/assets/img/react-redux.710f0a9f.png" alt="react-redux"></p> <h2 id="redux异步中间件之间的优劣"><a href="#redux异步中间件之间的优劣" class="header-anchor">#</a> redux异步中间件之间的优劣</h2> <h3 id="redux-thunk优点"><a href="#redux-thunk优点" class="header-anchor">#</a> redux-thunk优点</h3> <ul><li>体积小: redux-thunk的实现方式很简单,只有不到20行代码</li> <li>使用简单: redux-thunk没有引入像redux-saga或redux-observable额外的范式,上手简单</li></ul> <h3 id="redux-thunk缺陷"><a href="#redux-thunk缺陷" class="header-anchor">#</a> redux-thunk缺陷</h3> <ul><li>样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的</li> <li>耦合严重: 异步操作与redux的action偶合在一起,不方便管理</li> <li>功能孱弱: 有一些实际开发中常用的功能需要自己进行封装</li></ul> <h3 id="redux-saga优点"><a href="#redux-saga优点" class="header-anchor">#</a> redux-saga优点</h3> <ul><li>异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中</li> <li>action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function</li> <li>异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理</li> <li>功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者无须封装或者简单封装即可使用</li> <li>灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow</li> <li>易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等</li></ul> <h3 id="redux-saga缺陷"><a href="#redux-saga缺陷" class="header-anchor">#</a> redux-saga缺陷</h3> <ul><li>额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想</li> <li>体积庞大: 体积略大,代码近2000行，min版25KB左右</li> <li>功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码</li> <li>ts支持不友好: yield无法返回TS类型</li></ul> <h3 id="redux-observable优点"><a href="#redux-observable优点" class="header-anchor">#</a> redux-observable优点</h3> <ul><li>功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你能想到的异步处理</li> <li>背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而且随着rxjs的升级redux-observable也会变得更强大</li></ul> <h3 id="redux-observable缺陷"><a href="#redux-observable缺陷" class="header-anchor">#</a> redux-observable缺陷</h3> <ul><li>学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库</li> <li>社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步流中间件这个层面redux-saga仍处于领导地位</li></ul> <h2 id="redux与mobx的区别"><a href="#redux与mobx的区别" class="header-anchor">#</a> redux与mobx的区别</h2> <ul><li>redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中</li> <li>redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作</li> <li>redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改</li> <li>mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用</li> <li>mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
场景辨析:</li></ul> <p>基于以上区别,我们可以简单得分析一下两者的不同使用场景.</p> <ul><li>mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.</li> <li>redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于redux不可变的特性，天然支持这些操作.</li> <li>mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.</li> <li>当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用mobx作为组件局部状态管理器来</li></ul> <h2 id="为什么需要virtual-dom"><a href="#为什么需要virtual-dom" class="header-anchor">#</a> 为什么需要Virtual DOM</h2> <p>首先,我们都知道在前端性能优化的一个秘诀就是尽可能少地操作DOM,不仅仅是DOM相对较慢,更因为<strong>频繁变动DOM会造成浏览器的回流或者重绘,这些都是性能的杀手,因此我们需要这一层抽象,在patch过程中尽可能地一次性将差异更新到DOM中</strong>,这样保证了DOM不会出现性能很差的情况.</p> <p>其次,现代前端框架的一个基本要求就是无须手动操作DOM,一方面是因为<strong>手动操作DOM无法保证程序性能</strong>,多人协作的项目中如果review不严格,可能会有开发者写出性能较低的代码,另一方面更重要的是<strong>省略手动DOM操作可以大大提高开发效率</strong>.</p> <p>最后,也是Virtual DOM最初的目的,就是更好的<strong>跨平台</strong>,比如Node.js就没有DOM,如果想实现SSR(服务端渲染),那么一个方式就是借助Virtual DOM,因为Virtual DOM本身是JavaScript对象</p> <h2 id="react-hooks"><a href="#react-hooks" class="header-anchor">#</a> React Hooks</h2> <p>React Hooks是 React 16.7.0版本推出的新特性</p> <p>React Hooks 要解决的问题是<strong>状态共享</strong>，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX <strong>嵌套地狱</strong>问题。</p> <p>简单来说，Hook解决的就是“嵌套地狱”的问题，正如async解决“回调地狱”一样。它们都做到了将原来不同“维度”的代码封装到了同一维度，以达到更直观、透明的将“计算结果”传递下去的目的。</p> <p>而class不得不借助高阶组件等等概念，解决代码复用等问题，但是由于引入额外的概念（函数）反而使得代码更加复杂，现在的class难以解决这个问题，所以他就被抛弃了。</p> <p>使用useState可以将class组件中的state部分解耦出来，作为一个函数单独在多个组件之间公用，而在class组件中就需要封装高阶组件然后以props的形式传给子组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于useEffect来说，可以用来实现class组件的生命周期</p> <p>class实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useFriendStatus</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>handleStatusChange
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>
          prevProps<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>handleStatusChange
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>handleStatusChange
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

    <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>handleStatusChange
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent isOnline<span class="token operator">=</span><span class="token punctuation">{</span>isOnline<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>react hooks实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">FriendStatus</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isOnline<span class="token punctuation">,</span> setIsOnline<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">handleStatusChange</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setIsOnline</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span>isOnline<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Specify how to clean up after this effect:</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isOnline <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'Loading...'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> isOnline <span class="token operator">?</span> <span class="token string">'Online'</span> <span class="token operator">:</span> <span class="token string">'Offline'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// FriendStatus获取好友状态</span>
<span class="token keyword">function</span> <span class="token function">FriendStatus</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> isOnline <span class="token operator">=</span> <span class="token function">useFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isOnline <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'Loading...'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> isOnline <span class="token operator">?</span> <span class="token string">'Online'</span> <span class="token operator">:</span> <span class="token string">'Offline'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// FriendListItem获取好友状态</span>
<span class="token keyword">function</span> <span class="token function">FriendListItem</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> isOnline <span class="token operator">=</span> <span class="token function">useFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>li style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> color<span class="token operator">:</span> isOnline <span class="token operator">?</span> <span class="token string">'green'</span> <span class="token operator">:</span> <span class="token string">'black'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>name<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>上面例子中，使用useEffect能够将高阶组件的父组件生命周期中的含有副作用的功能解耦出去，避免了多一层的组件嵌套</p> <p>useState结合useEffect使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useRepos</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span> repos<span class="token punctuation">,</span> setRepos <span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span> loading<span class="token punctuation">,</span> setLoading <span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>

  React<span class="token punctuation">.</span><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setLoading</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>

    <span class="token function">fetchRepos</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">repos</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setRepos</span><span class="token punctuation">(</span>repos<span class="token punctuation">)</span>
        <span class="token function">setLoading</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span> loading<span class="token punctuation">,</span> repos <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>Talking about hooks：<a href="https://juejin.im/post/5d0ae589518825122925c2de" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5d0ae589518825122925c2de<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>为什么会出现React Hooks?：<a href="https://juejin.im/post/5d478b2d518825673a6ae1b9" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5d478b2d518825673a6ae1b9<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/17/2020, 1:42:11 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/interviewQuestions/浏览器.html" class="prev">
        浏览器
      </a></span> <span class="next"><a href="/interviewQuestions/Vue.html">
        Vue
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.a53673d4.js" defer></script><script src="/assets/js/2.666a23ec.js" defer></script><script src="/assets/js/5.40f9de20.js" defer></script>
  </body>
</html>
