<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | NMSN</title>
    <meta name="description" content="Somebody has to win, so why not be me?">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/favicon.ico">
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?6594ba1364804631f0a8fd4452766fed";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script aysnc="true" src="https://www.googletagmanager.com/gtag/js?id=UA-127895888-1"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-127895888-1');
  </script>
    
    <link rel="preload" href="/assets/css/0.styles.f2223a60.css" as="style"><link rel="preload" href="/assets/js/app.9ae6ea87.js" as="script"><link rel="preload" href="/assets/js/2.bc02613e.js" as="script"><link rel="preload" href="/assets/js/4.93588470.js" as="script"><link rel="prefetch" href="/assets/js/10.33d69f72.js"><link rel="prefetch" href="/assets/js/11.16cec77c.js"><link rel="prefetch" href="/assets/js/12.ef712230.js"><link rel="prefetch" href="/assets/js/13.421bac9a.js"><link rel="prefetch" href="/assets/js/14.95abbe65.js"><link rel="prefetch" href="/assets/js/15.4eb62500.js"><link rel="prefetch" href="/assets/js/16.1d393a30.js"><link rel="prefetch" href="/assets/js/17.1edba2c7.js"><link rel="prefetch" href="/assets/js/18.5eb6850f.js"><link rel="prefetch" href="/assets/js/19.118f292a.js"><link rel="prefetch" href="/assets/js/20.ce23b6c0.js"><link rel="prefetch" href="/assets/js/21.b26badd3.js"><link rel="prefetch" href="/assets/js/22.8d24a425.js"><link rel="prefetch" href="/assets/js/23.5ea3334f.js"><link rel="prefetch" href="/assets/js/24.04b146e9.js"><link rel="prefetch" href="/assets/js/25.996a42d0.js"><link rel="prefetch" href="/assets/js/26.fbc57e80.js"><link rel="prefetch" href="/assets/js/27.d18f313d.js"><link rel="prefetch" href="/assets/js/28.a63cb083.js"><link rel="prefetch" href="/assets/js/29.0db7bd47.js"><link rel="prefetch" href="/assets/js/3.9bc503d5.js"><link rel="prefetch" href="/assets/js/30.d5942e77.js"><link rel="prefetch" href="/assets/js/31.7123dbf7.js"><link rel="prefetch" href="/assets/js/32.6e90ead3.js"><link rel="prefetch" href="/assets/js/33.341a4714.js"><link rel="prefetch" href="/assets/js/34.1aa63eb6.js"><link rel="prefetch" href="/assets/js/35.d328cf37.js"><link rel="prefetch" href="/assets/js/36.a2e90bcb.js"><link rel="prefetch" href="/assets/js/37.7f26bb3d.js"><link rel="prefetch" href="/assets/js/38.3635987d.js"><link rel="prefetch" href="/assets/js/39.f0f44221.js"><link rel="prefetch" href="/assets/js/40.f93c5f3c.js"><link rel="prefetch" href="/assets/js/41.00994cbe.js"><link rel="prefetch" href="/assets/js/42.cec340b3.js"><link rel="prefetch" href="/assets/js/5.e61af707.js"><link rel="prefetch" href="/assets/js/6.f4fb216c.js"><link rel="prefetch" href="/assets/js/7.1eb5f357.js"><link rel="prefetch" href="/assets/js/8.1750f873.js"><link rel="prefetch" href="/assets/js/9.1d6ea5eb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f2223a60.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">NMSN</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/tech/" class="nav-link">
  快查总结
</a></div><div class="nav-item"><a href="/excerpt/" class="nav-link">
  摘录
</a></div><div class="nav-item"><a href="/interviewQuestions/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/readingNotes/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/work/" class="nav-link">
  工作总结
</a></div> <a href="https://github.com/nmsn" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/tech/" class="nav-link">
  快查总结
</a></div><div class="nav-item"><a href="/excerpt/" class="nav-link">
  摘录
</a></div><div class="nav-item"><a href="/interviewQuestions/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/readingNotes/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/work/" class="nav-link">
  工作总结
</a></div> <a href="https://github.com/nmsn" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interviewQuestions/CSS.html" class="sidebar-link">CSS</a></li><li><a href="/interviewQuestions/JS.html" class="sidebar-link">JS</a></li><li><a href="/interviewQuestions/Network.html" class="sidebar-link">网络</a></li><li><a href="/interviewQuestions/浏览器.html" class="sidebar-link">浏览器</a></li><li><a href="/interviewQuestions/React.html" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#fiber" class="sidebar-link">Fiber</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#setstate" class="sidebar-link">setState</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/React.html#diff" class="sidebar-link">diff</a></li></ul></li><li><a href="/interviewQuestions/Webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/interviewQuestions/设计模式.html" class="sidebar-link">设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" class="header-anchor">#</a> React</h1> <h2 id="fiber"><a href="#fiber" class="header-anchor">#</a> Fiber</h2> <p><a href="https://juejin.im/post/5c92f499f265da612647b754" target="_blank" rel="noopener noreferrer">原文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>产生原因：</p> <p>随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，
导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是<code>同步阻塞</code>。
在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用<code>同步递归</code>的方式进行遍历渲染，而这个过程最大的问题就是无法<code>暂停和恢复</code></p> <p>解决方法：</p> <p>解决同步阻塞的方法，通常有两种: <code>异步</code>与<code>任务分割</code>。而 React Fiber 便是为了实现任务分割而诞生的</p> <p>简述：</p> <ul><li>在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的<code>单链表树遍历算法</code>。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启</li> <li>这里我理解为是一种<code>任务分割调度算法</code>，主要是 将原先同步更新渲染的任务分割成一个个独立的<code>小任务单位</code>，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制</li></ul> <p>核心：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Fiber</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">instance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance
    <span class="token comment">// 指向第一个 child 节点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> child
    <span class="token comment">// 指向父节点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> parent
    <span class="token comment">// 指向第一个兄弟节点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> previous
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p><strong>链表树遍历算法</strong>: 通过<code>节点保存与映射</code>，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提</p> <ol><li>首先通过不断遍历子节点，到树末尾</li> <li>开始通过 sibling 遍历兄弟节点</li> <li>return 返回父节点，继续执行2</li> <li>直到 root 节点后，跳出遍历</li></ol></li> <li><p><strong>任务分割</strong>，React 中的渲染更新可以分成两个阶段:</p> <ul><li><strong>reconciliation</strong>阶段: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对</li> <li><strong>Commit</strong>阶段: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，
而导致数据更新和 UI 不一致的情况</li></ul></li> <li><p><strong>分散执行</strong>: 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，
而实现的关键是两个新API: <code>requestIdleCallback</code>与 <code>requestAnimationFrame</code></p> <ul><li><p>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，
而且拥有 deadline 参数，限制执行事件，以继续切分任务</p></li> <li><p>高优先级的任务交给<code>requestAnimationFrame</code>处理</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 类似于这样的方式</span>
<span class="token function">requestIdleCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当有空闲时间时，我们执行一个组件渲染；</span>
    <span class="token comment">// 把任务塞到一个个碎片时间中去；</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> deadline<span class="token punctuation">.</span>didTimeout<span class="token punctuation">)</span>
      <span class="token operator">&amp;&amp;</span> nextComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nextComponent <span class="token operator">=</span> <span class="token function">performWork</span><span class="token punctuation">(</span>nextComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p><strong>优先级策略</strong>:文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</p></li></ul> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p>v16.3版本之前的生命周期</p> <p><img src="/assets/img/react-old-lifecycle.8495df2e.png" alt="react生命周期"></p> <p>在v16.3中，React对生命周期有了新的<code>变动建议</code></p> <p><img src="/assets/img/react-new-lifecycle.89e2bedb.png" alt="react生命周期"></p> <ul><li>使用<code>getDerivedStateFromProps</code>替换<code>componentWillMount</code></li> <li>使用<code>getSnapshotBeforeUpdate</code>替换<code>componentWillUpdate</code></li> <li>避免使用<code>componentWillReceiveProps</code></li></ul> <p>其实该变动的原因，正是由于上述提到的 Fiber。首先，从上面我们知道 React 可以分成 reconciliation 与 commit 两个阶段，对应的生命周期如下:</p> <ul><li><p>reconciliation</p> <ul><li>componentWillMount</li> <li>componentWillReceiveProps</li> <li>shouldComponentUpdate</li> <li>componentWillUpdate</li></ul></li> <li><p>commit</p> <ul><li>componentDidMount</li> <li>componentDidUpdate</li> <li>componentWillUnmount</li></ul></li></ul> <p>在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被<code>多次调用</code>的情况，产生一些意外错误</p> <p>新的生命周期如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// 替换 `componentWillReceiveProps` ，</span>
  <span class="token comment">// 初始化和 update 时被调用</span>
  <span class="token comment">// 静态函数，无法使用 this</span>
  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 判断是否需要更新组件</span>
  <span class="token comment">// 可以用于组件性能优化</span>
  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 组件被挂载后触发</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 替换 componentWillUpdate</span>
  <span class="token comment">// 可以在更新之前获取最新 dom 数据</span>
  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 组件更新后调用</span>
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 组件即将销毁</span>
  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 组件已销毁</span>
  <span class="token function">componentDidUnMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="新的生命周期用法"><a href="#新的生命周期用法" class="header-anchor">#</a> 新的生命周期用法</h3> <p><img src="/assets/img/react_new_lifecycle_usage.6bfd8043.jpg" alt="新生命周期"></p> <h2 id="setstate"><a href="#setstate" class="header-anchor">#</a> setState</h2> <h3 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h3> <p>在了解setState之前，我们先来简单了解下 React 一个包装结构: <strong>Transaction</strong>:</p> <ul><li><strong>事务</strong>：
<ul><li>是 React 中的一个调用结构，用于包装一个方法，结构为: <strong>initialize - perform(method) - close</strong>。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作</li></ul></li></ul> <h3 id="setstate方法"><a href="#setstate方法" class="header-anchor">#</a> setState方法</h3> <p>React 中用于修改状态，更新视图。它具有以下特点:</p> <ul><li><p><strong>异步与同步</strong>： setState并不是单纯的异步或同步，这其实与调用时的环境相关</p> <ul><li><p>在<strong>合成事件</strong>和**生命周期钩子(除 componentDidUpdate)**中，setState是“异步”的</p> <ul><li><p>原因：因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新</p> <ul><li>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行</li> <li>在合成事件中，React 是基于<strong>事务流完成的事件委托机制</strong>实现，也是处于事务流中</li></ul></li> <li><p>问题：无法在setState后马上从this.state上获取更新后的值</p></li> <li><p>解决：如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值</p></li></ul></li> <li><p>在<strong>原生事件</strong>和<strong>setTimout</strong>中，setState是同步的，可以马上获得更新后的值</p> <ul><li>原因：原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步</li></ul></li></ul></li> <li><p><strong>批量更新</strong>：在<strong>合成事件</strong>和<strong>生命周期钩子</strong>中，setState更新队列时，存储的是<strong>合并状态</strong>(Object.assign)。
因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新</p></li> <li><p><strong>函数式</strong>：于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，
例如this.setState((state, props) =&gt; newState)</p> <ul><li>使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用。</li></ul></li></ul> <h2 id="diff"><a href="#diff" class="header-anchor">#</a> diff</h2> <p><img src="/assets/img/react_diff.6a6811a9.jpg" alt="diff"></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/5/2020, 5:01:42 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/interviewQuestions/浏览器.html" class="prev">
        浏览器
      </a></span> <span class="next"><a href="/interviewQuestions/Webpack.html">
        Webpack
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.9ae6ea87.js" defer></script><script src="/assets/js/2.bc02613e.js" defer></script><script src="/assets/js/4.93588470.js" defer></script>
  </body>
</html>
