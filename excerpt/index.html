<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>摘录 | NMSN</title>
    <meta name="description" content="Somebody has to win, so why not be me?">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/favicon.ico">
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?6594ba1364804631f0a8fd4452766fed";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script aysnc="true" src="https://www.googletagmanager.com/gtag/js?id=UA-127895888-1"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-127895888-1');
  </script>
    
    <link rel="preload" href="/assets/css/0.styles.f2223a60.css" as="style"><link rel="preload" href="/assets/js/app.3c063390.js" as="script"><link rel="preload" href="/assets/js/2.bf5c3b7d.js" as="script"><link rel="preload" href="/assets/js/13.62002494.js" as="script"><link rel="prefetch" href="/assets/js/10.ad044cb1.js"><link rel="prefetch" href="/assets/js/11.418d2985.js"><link rel="prefetch" href="/assets/js/12.ae05c919.js"><link rel="prefetch" href="/assets/js/14.ffbb4377.js"><link rel="prefetch" href="/assets/js/15.651abdcf.js"><link rel="prefetch" href="/assets/js/16.5de0cc24.js"><link rel="prefetch" href="/assets/js/17.a61d7dbb.js"><link rel="prefetch" href="/assets/js/18.f61fb97f.js"><link rel="prefetch" href="/assets/js/19.ec0ad3db.js"><link rel="prefetch" href="/assets/js/20.ca9d7824.js"><link rel="prefetch" href="/assets/js/21.11e0037d.js"><link rel="prefetch" href="/assets/js/22.857c4467.js"><link rel="prefetch" href="/assets/js/23.03bca5d1.js"><link rel="prefetch" href="/assets/js/24.2e9bfbf0.js"><link rel="prefetch" href="/assets/js/25.db244cf7.js"><link rel="prefetch" href="/assets/js/26.aab08bcc.js"><link rel="prefetch" href="/assets/js/27.b1e4b9fd.js"><link rel="prefetch" href="/assets/js/28.f0050d68.js"><link rel="prefetch" href="/assets/js/29.16588c20.js"><link rel="prefetch" href="/assets/js/3.f47e56c9.js"><link rel="prefetch" href="/assets/js/30.dcaa337b.js"><link rel="prefetch" href="/assets/js/31.101f4d5a.js"><link rel="prefetch" href="/assets/js/32.c06a85b2.js"><link rel="prefetch" href="/assets/js/33.4cafe749.js"><link rel="prefetch" href="/assets/js/34.8eb73cd1.js"><link rel="prefetch" href="/assets/js/35.492902a9.js"><link rel="prefetch" href="/assets/js/36.7465100e.js"><link rel="prefetch" href="/assets/js/37.90513eb9.js"><link rel="prefetch" href="/assets/js/38.6f79bfa3.js"><link rel="prefetch" href="/assets/js/39.e340ba52.js"><link rel="prefetch" href="/assets/js/4.b6f2262a.js"><link rel="prefetch" href="/assets/js/40.3cfd6250.js"><link rel="prefetch" href="/assets/js/41.700d73ae.js"><link rel="prefetch" href="/assets/js/42.643e382f.js"><link rel="prefetch" href="/assets/js/43.89f85e23.js"><link rel="prefetch" href="/assets/js/44.176bfc12.js"><link rel="prefetch" href="/assets/js/45.3f756d20.js"><link rel="prefetch" href="/assets/js/46.01e36c4b.js"><link rel="prefetch" href="/assets/js/5.b97501c3.js"><link rel="prefetch" href="/assets/js/6.b43a6f4a.js"><link rel="prefetch" href="/assets/js/7.e9a603b2.js"><link rel="prefetch" href="/assets/js/8.756166df.js"><link rel="prefetch" href="/assets/js/9.1355d887.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f2223a60.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">NMSN</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/tech/" class="nav-link">
  快查总结
</a></div><div class="nav-item"><a href="/excerpt/" class="nav-link router-link-exact-active router-link-active">
  摘录
</a></div><div class="nav-item"><a href="/interviewQuestions/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/readingNotes/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/work/" class="nav-link">
  工作总结
</a></div> <a href="https://github.com/nmsn" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/tech/" class="nav-link">
  快查总结
</a></div><div class="nav-item"><a href="/excerpt/" class="nav-link router-link-exact-active router-link-active">
  摘录
</a></div><div class="nav-item"><a href="/interviewQuestions/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/readingNotes/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/work/" class="nav-link">
  工作总结
</a></div> <a href="https://github.com/nmsn" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>摘录</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/excerpt/#行高" class="sidebar-link">行高</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#dom事件" class="sidebar-link">DOM事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/excerpt/#dom级别" class="sidebar-link">DOM级别</a></li></ul></li><li><a href="/excerpt/#event对象常见的应用" class="sidebar-link">Event对象常见的应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/excerpt/#event-preventdefault" class="sidebar-link">event. preventDefault()</a></li><li class="sidebar-sub-header"><a href="/excerpt/#touchstart-click" class="sidebar-link">touchstart &amp; click</a></li><li class="sidebar-sub-header"><a href="/excerpt/#event-stoppropagation-event-stopimmediatepropagation" class="sidebar-link">event.stopPropagation() &amp; event.stopImmediatePropagation()</a></li><li class="sidebar-sub-header"><a href="/excerpt/#event-target-event-currenttarget" class="sidebar-link">event.target &amp; event.currentTarget</a></li></ul></li><li><a href="/excerpt/#空格字符" class="sidebar-link">空格字符</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#muationobserver" class="sidebar-link">MuationObserver</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#css加载会造成阻塞吗" class="sidebar-link">css加载会造成阻塞吗</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#浏览器如果渲染过程遇到js文件怎么处理" class="sidebar-link">浏览器如果渲染过程遇到JS文件怎么处理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#浏览器多内核与js线程" class="sidebar-link">浏览器多内核与JS线程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#load和domcontentloadad区别" class="sidebar-link">Load和DOMContentLoadad区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#ios12键盘收起页面不回弹问题" class="sidebar-link">ios12键盘收起页面不回弹问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#在单页应用中，如何优雅的监听url的变化" class="sidebar-link">在单页应用中，如何优雅的监听url的变化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/excerpt/#_1-单页应用原理" class="sidebar-link">1. 单页应用原理</a></li><li class="sidebar-sub-header"><a href="/excerpt/#_2-监听url中的hash变化" class="sidebar-link">2. 监听url中的hash变化</a></li><li class="sidebar-sub-header"><a href="/excerpt/#_3-监听通过history来改变url的事件" class="sidebar-link">3. 监听通过history来改变url的事件</a></li></ul></li><li><a href="/excerpt/#深浅拷贝" class="sidebar-link">深浅拷贝</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/excerpt/#浅拷贝" class="sidebar-link">浅拷贝</a></li><li class="sidebar-sub-header"><a href="/excerpt/#深拷贝" class="sidebar-link">深拷贝</a></li></ul></li><li><a href="/excerpt/#console中的" class="sidebar-link">console中的'$'</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/excerpt/#_0" class="sidebar-link">$0</a></li><li class="sidebar-sub-header"><a href="/excerpt/#和" class="sidebar-link">$ 和 $$</a></li><li class="sidebar-sub-header"><a href="/excerpt/#" class="sidebar-link">$_</a></li></ul></li><li><a href="/excerpt/#settimeout-requestanimationframe" class="sidebar-link">setTimeout &amp; requestAnimationFrame</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#真值和虚值" class="sidebar-link">真值和虚值</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#object-fit" class="sidebar-link">object-fit</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#不同刷新的请求执行过程" class="sidebar-link">不同刷新的请求执行过程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#webkit-tap-highlight-color" class="sidebar-link">-webkit-tap-highlight-color</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#text-align-justify" class="sidebar-link">text-align:justify</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#sessionstorage共享问题" class="sidebar-link">sessionStorage共享问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#即时计算属性获取导致回流（reflow）" class="sidebar-link">即时计算属性获取导致回流（reflow）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#环境变量管理工具" class="sidebar-link">环境变量管理工具</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#进程-线程-携程" class="sidebar-link">进程 线程 携程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/excerpt/#进程" class="sidebar-link">进程</a></li><li class="sidebar-sub-header"><a href="/excerpt/#线程" class="sidebar-link">线程</a></li><li class="sidebar-sub-header"><a href="/excerpt/#协程" class="sidebar-link">协程</a></li></ul></li><li><a href="/excerpt/#click事件存在的问题" class="sidebar-link">click事件存在的问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/excerpt/#ie" class="sidebar-link">IE</a></li><li class="sidebar-sub-header"><a href="/excerpt/#safari" class="sidebar-link">Safari</a></li></ul></li><li><a href="/excerpt/#文本换行css属性" class="sidebar-link">文本换行css属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/excerpt/#overflow-wrap-word-warp" class="sidebar-link">overflow-wrap (word-warp)</a></li><li class="sidebar-sub-header"><a href="/excerpt/#word-break" class="sidebar-link">word-break</a></li><li class="sidebar-sub-header"><a href="/excerpt/#white-space" class="sidebar-link">white-space</a></li></ul></li><li><a href="/excerpt/#自定义滚动条样式" class="sidebar-link">自定义滚动条样式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#npm" class="sidebar-link">npm</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/excerpt/#npm-2-x-嵌套结构" class="sidebar-link">npm 2.x - 嵌套结构</a></li><li class="sidebar-sub-header"><a href="/excerpt/#npm-3-x-扁平结构" class="sidebar-link">npm 3.x - 扁平结构</a></li><li class="sidebar-sub-header"><a href="/excerpt/#npm-5-x-package-lock-json" class="sidebar-link">npm 5.x - package-lock.json</a></li><li class="sidebar-sub-header"><a href="/excerpt/#依赖包版本号" class="sidebar-link">依赖包版本号</a></li><li class="sidebar-sub-header"><a href="/excerpt/#版本格式" class="sidebar-link">版本格式</a></li><li class="sidebar-sub-header"><a href="/excerpt/#npm-script" class="sidebar-link">npm script</a></li><li class="sidebar-sub-header"><a href="/excerpt/#多命令运行" class="sidebar-link">多命令运行</a></li><li class="sidebar-sub-header"><a href="/excerpt/#oliver-steele的嵌套对象访问模式" class="sidebar-link">Oliver Steele的嵌套对象访问模式</a></li><li class="sidebar-sub-header"><a href="/excerpt/#如何让-a-1-a-2-a-3" class="sidebar-link">如何让 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</a></li></ul></li><li><a href="/excerpt/#new的实现原理" class="sidebar-link">new的实现原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#为什么div里嵌套了img底部会有白块" class="sidebar-link">为什么div里嵌套了img底部会有白块</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#前后端鉴权" class="sidebar-link">前后端鉴权</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/excerpt/#http-basic-authentication" class="sidebar-link">HTTP Basic Authentication</a></li><li class="sidebar-sub-header"><a href="/excerpt/#session-cookie" class="sidebar-link">session-cookie</a></li><li class="sidebar-sub-header"><a href="/excerpt/#token" class="sidebar-link">Token</a></li><li class="sidebar-sub-header"><a href="/excerpt/#oauth-开放授权" class="sidebar-link">OAuth(开放授权)</a></li></ul></li><li><a href="/excerpt/#npm-参数问题" class="sidebar-link">npm 参数问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#最后一行列表左对齐的n种方式" class="sidebar-link">最后一行列表左对齐的N种方式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#函数式编程" class="sidebar-link">函数式编程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/excerpt/#solid（面向对象设计）" class="sidebar-link">SOLID（面向对象设计）</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="摘录"><a href="#摘录" class="header-anchor">#</a> 摘录</h1> <h2 id="行高"><a href="#行高" class="header-anchor">#</a> 行高</h2> <p>参考: <a href="https://juejin.im/post/5bfa8f4be51d4574b133d0a0" target="_blank" rel="noopener noreferrer">前端读书寻宝记之读《包容性Web设计》有感<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>行高要设置成无单位的相对值，建议1.5倍间距</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">p</span><span class="token punctuation">{</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 1rem<span class="token punctuation">;</span>
    <span class="token property">line-height</span><span class="token punctuation">:</span> 1.5<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="dom事件"><a href="#dom事件" class="header-anchor">#</a> DOM事件</h2> <h3 id="dom级别"><a href="#dom级别" class="header-anchor">#</a> DOM级别</h3> <p>参考: <a href="https://juejin.im/post/5bd2e5f8e51d4524640e1304" target="_blank" rel="noopener noreferrer">DOM事件机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>DOM级别一共可以分为四个级别：DOM0级、DOM1级、DOM2级和DOM3级。
而DOM事件分为3个级别：DOM 0级事件处理，DOM 2级事件处理和DOM 3级事件处理。由于DOM 1级中没有事件的相关内容，所以没有DOM 1级事件。</p> <h4 id="dom0级"><a href="#dom0级" class="header-anchor">#</a> DOM0级</h4> <div class="language-js extra-class"><pre class="language-js"><code>element<span class="token punctuation">.</span>on<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>当给元素绑定多个同类型事件时，最后一个事件会覆盖前面的事件。</p> <p>绑定事件在当前元素的冒泡阶段（或者目标阶段）执行。</p> <h4 id="dom2级"><a href="#dom2级" class="header-anchor">#</a> DOM2级</h4> <div class="language-js extra-class"><pre class="language-js"><code>element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>event<span class="token operator">-</span>name<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> useCapture<span class="token punctuation">)</span>
</code></pre></div><p>参数：</p> <ul><li>event-name: 事件名称，可以是标准的DOM事件</li> <li>callback: 回调函数，当事件触发时，函数会被注入一个参数为当前的事件对象 event</li> <li>useCapture: 默认是false，代表事件句柄在冒泡阶段执行（事件句柄）</li></ul> <p>可以同一元素绑定多个同类型事件（执行顺序有待实验）</p> <h4 id="dom3级"><a href="#dom3级" class="header-anchor">#</a> DOM3级</h4> <p>在DOM2级事件的基础上添加了更多的事件类型</p> <ul><li>UI事件，当用户与页面上的元素交互时触发，如：load、scroll</li> <li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li> <li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup</li> <li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li> <li>文本事件，当在文档中输入文本时触发，如：textInput</li> <li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li> <li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</li> <li>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</li> <li>同时DOM3级事件也允许使用者自定义一些事件。</li></ul> <h2 id="event对象常见的应用"><a href="#event对象常见的应用" class="header-anchor">#</a> Event对象常见的应用</h2> <h3 id="event-preventdefault"><a href="#event-preventdefault" class="header-anchor">#</a> event. preventDefault()</h3> <p>阻止默认事件行为触发</p> <h3 id="touchstart-click"><a href="#touchstart-click" class="header-anchor">#</a> touchstart &amp; click</h3> <p>意思的是，当我们在目标元素同时绑定 touchstart 和 click 事件时，在 touchstart 事件回调函数中使用该方法，可以阻止后续 click 事件的发生。</p> <h3 id="event-stoppropagation-event-stopimmediatepropagation"><a href="#event-stoppropagation-event-stopimmediatepropagation" class="header-anchor">#</a> event.stopPropagation() &amp; event.stopImmediatePropagation()</h3> <p>event.stopPropagation() 方法阻止事件冒泡到父元素，阻止任何父事件处理程序被执行</p> <p>event.stopImmediatePropagation 既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发</p> <h3 id="event-target-event-currenttarget"><a href="#event-target-event-currenttarget" class="header-anchor">#</a> event.target &amp; event.currentTarget</h3> <p>event.target指向引起触发事件的元素，而event.currentTarget则是事件绑定的元素，只有被点击的那个目标元素的event.target才会等于event.currentTarget。也就是说，event.currentTarget始终是监听事件者，而event.target是事件的真正发出者。</p> <h2 id="空格字符"><a href="#空格字符" class="header-anchor">#</a> 空格字符</h2> <p>参考: <a href="https://www.zhangxinxu.com/wordpress/2015/01/tips-blank-character-chinese-align/" target="_blank" rel="noopener noreferrer">小tips: 使用　等空格实现最小成本中文对齐<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <table><thead><tr><th>字符以及HTML实体</th> <th>描述以及说明</th></tr></thead> <tbody><tr><td><code>&amp;nbsp;</code></td> <td>这是我们使用最多的空格，也就是按下space键产生的空格。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。</td></tr> <tr><td>要使用html实体表示才可累加。为了便于记忆，我总是把这个空格成为“牛逼(nb)空格(sp – space)”，虽然实际上并不牛逼。该空格占据宽度受字体影响明显而强烈。在inline-block布局中会搞些小破坏，在两端对齐布局中又是不可少的元素。是个让人又爱又恨的小东东。</td> <td></td></tr> <tr><td><code>&amp;ensp;</code></td> <td>该空格学名不详。为了便于记忆，我们不妨就叫它“恶念(e n-ian)空格”。此空格传承空格家族一贯的特性：透明滴！此空格有个相当稳健的特性，就是其<strong>占据的宽度正好是1/2个中文宽度</strong>，而且基本上不受字体影响。</td></tr> <tr><td><code>&amp;emsp;</code></td> <td>该空格学名不详。为了便于记忆，我们不妨就叫它”恶魔(e m-o)空格”。此空格也传承空格家族一贯的特性：透明滴！此空格也有个相当稳健的特性，就是其<strong>占据的宽度正好是1个中文宽度</strong>，而且基本上不受字体影响。</td></tr> <tr><td><code>&amp;thinsp;</code></td> <td>该空格学名不详。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。我目前是没用过这个东西，这里亮出来是让其过一下群众演员的瘾</td></tr></tbody></table> <h2 id="muationobserver"><a href="#muationobserver" class="header-anchor">#</a> MuationObserver</h2> <p>参考：<a href="https://segmentfault.com/a/1190000012787829" target="_blank" rel="noopener noreferrer">了解HTML5中的MutationObserver<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>MutationObserver翻译过来就是变动观察器，字面上就可以理解这是用来观察Node（节点）变化的。</p> <p>MutationObserver是一个构造器，接受一个callback参数，用来处理节点变化的回调函数，返回两个参数，mutations：节点变化记录列表（<code>sequence&lt;MutationRecord&gt;</code>），observer：构造MutationObserver对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> observe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">mutations<span class="token punctuation">,</span>observer</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>MutationObserver对象有三个方法，分别如下：</p> <ol><li><strong>observe</strong>：设置观察目标，接受两个参数，target：观察目标，options：通过对象成员来设置观察选项</li> <li><strong>disconnect</strong>：阻止观察者观察任何改变</li> <li><strong>takeRecords</strong>：清空记录队列并返回里面的内容</li></ol> <p>关于observe方法中options参数有已下几个选项：</p> <ol><li><strong>childList</strong>：设置true，表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</li> <li><strong>attributes</strong>：设置true，表示观察目标属性的改变</li> <li><strong>characterData</strong>：设置true，表示观察目标数据的改变</li> <li><strong>subtree</strong>：设置为true，目标以及目标的后代改变都会观察</li> <li><strong>attributeOldValue</strong>：如果属性为true或者省略，则相当于设置为true，表示需要记录改变前的目标属性值，设置了attributeOldValue可以省略attributes设置</li> <li><strong>characterDataOldValue</strong>：如果characterData为true或省略，则相当于设置为true,表示需要记录改变之前的目标数据，设置了characterDataOldValue可以省略characterData设置</li> <li><strong>attributeFilter</strong>：如果不是所有的属性改变都需要被观察，并且attributes设置为true或者被忽略，那么设置一个需要观察的属性本地名称（不需要命名空间）的列表</li></ol> <h2 id="css加载会造成阻塞吗"><a href="#css加载会造成阻塞吗" class="header-anchor">#</a> css加载会造成阻塞吗</h2> <p>参考：<a href="https://www.cnblogs.com/chenjg/p/7126822.html" target="_blank" rel="noopener noreferrer">css加载会造成阻塞吗？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol><li>css加载不会阻塞DOM解析</li> <li>css加载会阻塞DOM树的渲染</li> <li>css加载会阻塞后面js语句的执行</li></ol> <h2 id="浏览器如果渲染过程遇到js文件怎么处理"><a href="#浏览器如果渲染过程遇到js文件怎么处理" class="header-anchor">#</a> 浏览器如果渲染过程遇到JS文件怎么处理</h2> <p>原文：<a href="https://juejin.im/post/5ca0c0abe51d4553a942c17d?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener noreferrer">你不知道的浏览器页面渲染机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>渲染过程中，如果遇到<code>&lt;script&gt;</code>就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，
而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。</p> <p>JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。</p> <p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。
当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。</p> <p>原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。</p> <p>这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。</p> <h2 id="浏览器多内核与js线程"><a href="#浏览器多内核与js线程" class="header-anchor">#</a> 浏览器多内核与JS线程</h2> <p>原文：<a href="https://segmentfault.com/a/1190000013083967" target="_blank" rel="noopener noreferrer">浅谈浏览器多进程与JS线程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li>图形用户界面GUI渲染线程
<ul><li>负责渲染浏览器界面，包括解析HTML、CSS、构建DOM树、Render树、布局与绘制等</li> <li>当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行</li></ul></li> <li>JS引擎线程
<ul><li>JS内核，也称JS引擎，负责处理执行javascript脚本</li> <li>等待任务队列的任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS引擎在运行JS程序</li></ul></li> <li>事件触发线程
<ul><li>听起来像JS的执行，但其实归属于浏览器，而不是JS引擎，用来控制时间循环</li> <li>当JS引擎执行代码如setTimeout时，会将对应任务添加到事件线程中</li> <li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li> <li>注意：由于JS单线程关系，所以这些待处理队列中过的事件都得排队等待JS引擎处理</li></ul></li> <li>定时触发器线程
<ul><li>setIntervel与setTimeout所在线程</li> <li>定时计时器并不是又JS引擎计时的，因为如果JS引擎时单线程又处于堵塞状态，那回影响到及时的准确</li> <li>当计时完成被触发，事件会被添加到事件队列，等待JS引擎空闲了执行</li></ul></li> <li>异步HTTP请求线程
<ul><li>在XMLHttpRequest在连接后新启动的一个线程</li> <li>线程如果检测到请求的状态变更，如果设置又回调函数，该线程会把回调函数添加到事件队列，同理，等待JS引擎空闲了执行</li></ul></li></ul> <p>setTimout不是内置的JS函数，而是浏览器API( Browser API)的一部分，它是浏览器免费提供给我们的一组方便的工具</p> <h2 id="load和domcontentloadad区别"><a href="#load和domcontentloadad区别" class="header-anchor">#</a> Load和DOMContentLoadad区别</h2> <ul><li>DOMContentLoaded事件将在DOM层次结构完全构建后立即触发</li> <li>Load事件将在所有图像和CSS文件完成加载后执行</li></ul> <h2 id="ios12键盘收起页面不回弹问题"><a href="#ios12键盘收起页面不回弹问题" class="header-anchor">#</a> ios12键盘收起页面不回弹问题</h2> <p>原文: <a href="https://juejin.im/post/5c07442f51882528c4469769?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener noreferrer">ios 最新系统bug与解决——微信公众号中弹出键盘再收起时，原虚拟键盘位点击事件无效<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token regex">/iphone|ipod|ipad/i</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>navigator<span class="token punctuation">.</span>appVersion<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
  document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'blur'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里加了个类型判断，因为a等元素也会触发blur事件</span>
    <span class="token punctuation">[</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token string">'textarea'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>localName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">scrollIntoView</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="在单页应用中，如何优雅的监听url的变化"><a href="#在单页应用中，如何优雅的监听url的变化" class="header-anchor">#</a> 在单页应用中，如何优雅的监听url的变化</h2> <p>原文: <a href="https://juejin.im/post/5c26ec2f51882501cd6f497a" target="_blank" rel="noopener noreferrer">在单页应用中，如何优雅的监听url的变化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_1-单页应用原理"><a href="#_1-单页应用原理" class="header-anchor">#</a> 1. 单页应用原理</h3> <p>通过hash或者html5 Bom对象中的history可以做到改变url，但是不刷新页面。</p> <p>(1)通过hash来实现单页路由</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash
</code></pre></div><p>(2)通过history实现前端路由</p> <p>HTML5的History接口，History对象是一个底层接口，不继承于任何的接口。History接口允许我们操作浏览器会话历史记录。</p> <p>属性:</p> <ul><li>History.length</li> <li>History.state</li></ul> <p>方法:</p> <ul><li>History.back (会刷新)</li> <li>History.forward (会刷新)</li> <li>History.go (会刷新)</li> <li>History.pushState (不会刷新)</li> <li>History.replaceState (不会刷新)</li></ul> <h3 id="_2-监听url中的hash变化"><a href="#_2-监听url中的hash变化" class="header-anchor">#</a> 2. 监听url中的hash变化</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span>
window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token number">2.</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><h3 id="_3-监听通过history来改变url的事件"><a href="#_3-监听通过history来改变url的事件" class="header-anchor">#</a> 3. 监听通过history来改变url的事件</h3> <p>监听 back,forward和go</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'popstate'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>监听 replaceState和pushState</p> <p>手动创建全局事件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">_wr</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> orig <span class="token operator">=</span> history<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">var</span> rv <span class="token operator">=</span> <span class="token function">orig</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
       e<span class="token punctuation">.</span>arguments <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
       window<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> rv<span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 history<span class="token punctuation">.</span>pushState <span class="token operator">=</span> <span class="token function">_wr</span><span class="token punctuation">(</span><span class="token string">'pushState'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 history<span class="token punctuation">.</span>replaceState <span class="token operator">=</span> <span class="token function">_wr</span><span class="token punctuation">(</span><span class="token string">'replaceState'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'replaceState'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'THEY DID IT AGAIN! replaceState 111111'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'pushState'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'THEY DID IT AGAIN! pushState 2222222'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="深浅拷贝"><a href="#深浅拷贝" class="header-anchor">#</a> 深浅拷贝</h2> <h3 id="浅拷贝"><a href="#浅拷贝" class="header-anchor">#</a> 浅拷贝</h3> <ul><li><p>Object.assign()</p></li> <li><p>拓展运算符</p></li> <li><p>Array.prototype.slice()</p></li></ul> <h3 id="深拷贝"><a href="#深拷贝" class="header-anchor">#</a> 深拷贝</h3> <ul><li>JSON.stringify()</li></ul> <p>注意事项:</p> <ol><li>拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失。</li> <li>无法拷贝不可枚举的属性，无法拷贝对象的原型链。</li> <li>拷贝Date引用类型会变成字符串。</li> <li>拷贝RegExp引用类型会变成空对象。</li> <li>对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null。</li> <li>无法拷贝对象的循环应用(即obj[key] = obj)。</li></ol> <ul><li>lodash &amp; jQuery</li></ul> <h2 id="console中的"><a href="#console中的" class="header-anchor">#</a> console中的'$'</h2> <h3 id="_0"><a href="#_0" class="header-anchor">#</a> $0</h3> <p>在Chrome的Elements面板中，$0 是当前我们选中的html节点的引用。</p> <p>理所当然，$1 是我们上一次选择的节点的引用，$2 是在那之前选择的节点的引用，等等。一直到 $4。</p> <h3 id="和"><a href="#和" class="header-anchor">#</a> $ 和 $$</h3> <p>在你还没有在app中定义 $变量的情况下(例如 jQuery)，$在console中是冗长的函数document.querySelector的一个别名。
但是$$ 能节省更多的时间，因为它不仅仅执行document.QuerySelectorAll并且返回的是一个节点的数组，而不是一个Node list
从本质上说:Array.from(document.querySelectorAll('div')) === $$('div'),但是$$('div')要简短太多了！</p> <h3 id=""><a href="#" class="header-anchor">#</a> $_</h3> <p>$_变量是上次执行的结果的引用。</p> <h2 id="settimeout-requestanimationframe"><a href="#settimeout-requestanimationframe" class="header-anchor">#</a> setTimeout &amp; requestAnimationFrame</h2> <p>原文: <a href="https://juejin.im/post/5c3ca3d76fb9a049a979f429" target="_blank" rel="noopener noreferrer">你知道的requestAnimationFrame【从0到0.1】<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li><p>使用 setTimeout 实现的动画，当页面被隐藏或最小化时，定时器setTimeout仍在后台执行动画任务，
此时刷新动画是完全没有意义的（实际上 FireFox/Chrome 浏览器对定时器做了优化：页面闲置时，如果时间间隔小于 1000ms，则停止定时器，与requestAnimationFrame行为类似。如果时间间隔&gt;=1000ms，定时器依然在后台执行）</p></li> <li><p>使用requestAnimationFrame，当页面处于未激活的状态下，该页面的屏幕刷新任务会被系统暂停，
由于requestAnimationFrame保持和屏幕刷新同步执行，所以也会被暂停。当页面被激活时，动画从上次停留的地方继续执行，节约 CPU 开销。</p></li></ul> <h2 id="真值和虚值"><a href="#真值和虚值" class="header-anchor">#</a> 真值和虚值</h2> <p>原文: <a href="https://juejin.im/post/5c4506c9e51d45524c7cf206" target="_blank" rel="noopener noreferrer">[译] 优秀 JavaScript 开发人员应掌握的 9 个技巧<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>当我们使用默认值时，通常要对现有值进行一系列判断，这种方法使代码变得异常繁琐，而现在我们可以真值（Truthy）和虚值（Falsy）的方式来改进它，不仅可以节省代码量，还使人更加信服。</p> <p>Falsy</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>all<span class="token punctuation">)</span>
</code></pre></div><p>Truthy</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3.14</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="object-fit"><a href="#object-fit" class="header-anchor">#</a> object-fit</h2> <p>当你在CSS中改变一个图片的大小，如果没有设置宽高的话，图片的大小会被压缩或拉伸。
解决方法很简单，就是使用CSS的 object-fit，它的实用性跟背景图片的 background-size: cover 很类似。</p> <p>链接: <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit" target="_blank" rel="noopener noreferrer">object-fit<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><code>object-fit</code> CSS 属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。</p> <p>取值:</p> <p><code>contain</code></p> <p>被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。 整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加“黑边”。</p> <p><code>cover</code></p> <p>被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框。</p> <p><code>fill</code></p> <p>被替换的内容正好填充元素的内容框。整个对象将完全填充此框。如果对象的宽高比与内容框不相匹配，那么该对象将被拉伸以适应内容框。</p> <p><code>none</code></p> <p>被替换的内容将保持其原有的尺寸。</p> <p><code>scale-down</code></p> <p>内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。</p> <h2 id="不同刷新的请求执行过程"><a href="#不同刷新的请求执行过程" class="header-anchor">#</a> 不同刷新的请求执行过程</h2> <p>原文: <a href="https://juejin.im/post/5a1d4e546fb9a0450f21af23" target="_blank" rel="noopener noreferrer">HTTP----HTTP缓存机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol><li>浏览器地址栏中写入URL，回车
浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）</li> <li>F5<br>
F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since。</li> <li>Ctrl+F5<br>
告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作。</li></ol> <h2 id="webkit-tap-highlight-color"><a href="#webkit-tap-highlight-color" class="header-anchor">#</a> -webkit-tap-highlight-color</h2> <p>这个属性只用于iOS（iPhone和iPad）。当你点击一个链接或者通过Javascript定义的可点击元素的时候，它就会出现一个半透明的灰色背景。要重设这个表现，你可以设置-webkit-tap-highlight-color为任何颜色。</p> <p>想要禁用这个高亮，设置颜色的alpha值为0即可。</p> <h2 id="text-align-justify"><a href="#text-align-justify" class="header-anchor">#</a> text-align:justify</h2> <p>text-align:justify 属性规定元素中的文本水平对齐方式为两端对齐文本效果。</p> <p>移动端<code>&amp;npsp``&amp;ensp``&amp;emsp``&amp;thinsp</code>的显示效果与浏览器端不同，不能够完美占位就需要使用text-align: justify;</p> <p>但该属性对于单行及多行的最后一行不起作用，可以用（伪类）伪元素解决</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">::after</span><span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="sessionstorage共享问题"><a href="#sessionstorage共享问题" class="header-anchor">#</a> sessionStorage共享问题</h2> <p>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。
在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。</p> <p><strong>通过点击链接（或者用了window.open）打开的新标签页之间是属于同一个 session 的</strong>，
但新开一个标签页总是会初始化一个新的 session，即使网站是一样的，它们也不属于同一个 session。</p> <h2 id="即时计算属性获取导致回流（reflow）"><a href="#即时计算属性获取导致回流（reflow）" class="header-anchor">#</a> 即时计算属性获取导致回流（reflow）</h2> <p>offset(Top/Left/Width/Height)</p> <p>scroll(Top/Left/Width/Height)</p> <p>client(Top/Left/Width/Height)</p> <p>...</p> <p>使用这些属性时，需要通过及时计算得到，因此浏览器为了获取这些值，也会进行回流</p> <h2 id="环境变量管理工具"><a href="#环境变量管理工具" class="header-anchor">#</a> 环境变量管理工具</h2> <ul><li>dotenv 可以解决跨平台和持久化的问题，但使用场景有限，只适用于node项目，且和项目代码强耦合，需要在弄得代码运行后手动执行触发</li> <li>cross-env 支持在命令行自定义环境变量。问题也非常明显，不能解决大型项目中自定义环境变量的持久化问题</li> <li>env-cmd 也可以解决跨平台和持久化的问题，支持定义默认环境变量，不足的是不支持在命令行自定义环境变量</li></ul> <h2 id="进程-线程-携程"><a href="#进程-线程-携程" class="header-anchor">#</a> 进程 线程 携程</h2> <h3 id="进程"><a href="#进程" class="header-anchor">#</a> 进程</h3> <p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p> <p>组成</p> <p>进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。</p> <p>特征</p> <p>动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。
并发性：任何进程都可以同其他进程一起并发执行
独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；
异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进
结构特征：进程由程序、数据和进程控制块三部分组成。
多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p> <h3 id="线程"><a href="#线程" class="header-anchor">#</a> 线程</h3> <p>在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。</p> <ul><li><p>轻型实体
线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。
线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：</p> <ul><li>线程状态。</li> <li>当线程不运行时，被保存的现场资源。</li> <li>一组执行堆栈。</li> <li>存放每个线程的局部变量主存区。</li> <li>访问同一个进程中的主存和其它资源。
用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</li></ul></li> <li><p>独立调度和分派的基本单位。
在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</p></li> <li><p>可并发执行。
在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</p></li> <li><p>共享进程资源。</p></li></ul> <p>在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</p> <h3 id="协程"><a href="#协程" class="header-anchor">#</a> 协程</h3> <p>协程与子例程一样，协程（coroutine）也是一种程序组件。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。
协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。</p> <p>协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。
一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。</p> <p>协程和线程区别：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。</p> <h2 id="click事件存在的问题"><a href="#click事件存在的问题" class="header-anchor">#</a> click事件存在的问题</h2> <h3 id="ie"><a href="#ie" class="header-anchor">#</a> IE</h3> <p>IE8&amp;9，具有background-color样式计算为transparent的元素覆盖在其他元素顶端时，不会收到click事件。取而代之，所有的click事件将被触发于其地下的元素</p> <p>已知会触发此漏洞的情景:</p> <ul><li>仅针对IE9
<ul><li>设置<code>background-color: rgba(0,0,0,0)</code></li> <li>设置<code>opacity: 0</code>并且明确指定background-color而不是transparent</li></ul></li> <li>对于IE8和IE9: 设置<code>filter: alpha(opacity = 0);</code>并且明确指定<code>background-color</code>而不是transparent</li></ul> <h3 id="safari"><a href="#safari" class="header-anchor">#</a> Safari</h3> <p>safari手机版会有一个bug，当点击事件不是绑定在交互式的元素上（比如说HTML的div），并且也没有直接的事件监听器绑定在他们自身。</p> <p>解决方法如下：</p> <p>为其元素或者祖先元素，添加cursor: pointer的样式，使元素具有交互式点击为需要交互式点击的元素添加onclick=&quot;void(0)&quot;的属性，但并不包括body元素使用可点击元素如<code>&lt;a&gt;</code>,代替不可交互式元素如div不使用click的事件委托。</p> <p>Safari 手机版里，以下元素不会受到上述bug的影响：</p> <ul><li><code>&lt;a&gt;</code> 需要href链接</li> <li><code>&lt;area&gt;</code> 需要href</li> <li><code>&lt;button&gt;</code></li> <li><code>&lt;img&gt;</code></li> <li><code>&lt;input&gt;</code></li> <li><code>&lt;label&gt;</code> 需要与form控制器连接</li></ul> <h2 id="文本换行css属性"><a href="#文本换行css属性" class="header-anchor">#</a> 文本换行css属性</h2> <h3 id="overflow-wrap-word-warp"><a href="#overflow-wrap-word-warp" class="header-anchor">#</a> overflow-wrap (word-warp)</h3> <p>控制单词如何被拆分换行</p> <p>用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行</p> <ul><li>normal 表示在正常的单词结束处换行</li> <li>break-word 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分隔的单词会被强制分隔换行</li></ul> <h3 id="word-break"><a href="#word-break" class="header-anchor">#</a> word-break</h3> <p>指定了怎样在单词内断行</p> <ul><li>normal 使用默认的断行规则</li> <li>break-all 对于non-CJK（CJK指中文/日文/韩文）文本，可在任意字符间断行</li> <li>keep-all CJK文本不断行。Non-CJK文本表现同normal</li> <li>break-word （非标准）</li></ul> <h3 id="white-space"><a href="#white-space" class="header-anchor">#</a> white-space</h3> <p>用来设置如何处理元素中的空白</p> <ul><li>normal 连续的空白会被合并，换行符会被空白符来处理，填充line盒子时，必要的话会换行</li> <li>nowrap 和normal一样，连续的空白符会被合并。但文本内的换行无效</li> <li>pre 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素时才会换行</li> <li>pre-wrap 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时才会换行</li> <li>pre-line 连续的空白符会被合并。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时才会换行</li></ul> <h2 id="自定义滚动条样式"><a href="#自定义滚动条样式" class="header-anchor">#</a> 自定义滚动条样式</h2> <ul><li>整体部分，::-webkit-scrollbar;</li> <li>两端按钮，::-webkit-scrollbar-button;</li> <li>外层轨道，::-webkit-scrollbar-track;</li> <li>内层轨道，::-webkit-scrollbar-track-piece;</li> <li>滚动滑块，::-webkit-scrollbar-thumb;</li> <li>边角部分，::-webkit-scrollbar-corner;</li></ul> <h2 id="npm"><a href="#npm" class="header-anchor">#</a> npm</h2> <p>原文: <a href="https://juejin.im/post/5d08d3d3f265da1b7e103a4d?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener noreferrer">你所需要的npm知识储备都在这了<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="npm-2-x-嵌套结构"><a href="#npm-2-x-嵌套结构" class="header-anchor">#</a> npm 2.x - 嵌套结构</h3> <p>npm 2.x安装依赖方式比较简单直接，以递归的方式按照包依赖的树形结构下载填充本地目录结构，也就是说每个包都会将该包的依赖安装到当前包所在的node_modules目录中</p> <h3 id="npm-3-x-扁平结构"><a href="#npm-3-x-扁平结构" class="header-anchor">#</a> npm 3.x - 扁平结构</h3> <p>npm 3.x则采用了扁平化的结构来安装组织node_modules。也就是在执行npm install的时候，
按照package.json 里依赖的顺序依次解析，遇到新的包就把它放在第一级目录，
后面如果遇到一级目录已经存在的包，会先按照约定版本判断版本，如果符合版本约定则忽略，否则会按照npm 2.x的方式依次挂在依赖包目录下</p> <h3 id="npm-5-x-package-lock-json"><a href="#npm-5-x-package-lock-json" class="header-anchor">#</a> npm 5.x - package-lock.json</h3> <p>npm为了让开发者在安全的前提下使用最新的依赖包，在package.json中通常做了锁定大版本的操作，这样在每次npm install的时候都会拉去依赖包大版本下的最新的版本。这种机制最大的一个缺点就是当有依赖包有小版本更新时，可能会出现协同开发者的依赖包不一致的问题</p> <p>package-lock.json文件精确描述了node_modules目录下所有的包的树状依赖结构，每个包的版本都是完全精确的</p> <ul><li>version: 包唯一的版本号</li> <li>resolved: 安装源</li> <li>integrity: 表明包完整性的hash值（验证包是否已失效）</li> <li>dev: 如果为true，则此依赖关系仅是顶级模块的开发依赖关系或者是一个的传递依赖关系</li> <li>require: 依赖包所需要的所有依赖项，对应依赖包package.json里dependencies中的依赖项</li> <li>dependencies: 依赖包node_modules中依赖的包，与顶层的dependencies一样的结构</li></ul> <h3 id="依赖包版本号"><a href="#依赖包版本号" class="header-anchor">#</a> 依赖包版本号</h3> <p>npm采用了语义化版本（semver）规范作为依赖版本管理方案 （x.y.z）</p> <h4 id="主版本号（major-version）"><a href="#主版本号（major-version）" class="header-anchor">#</a> 主版本号（major version）</h4> <h4 id="次版本号（minor-version）"><a href="#次版本号（minor-version）" class="header-anchor">#</a> 次版本号（minor version）</h4> <h4 id="修订号（patch）"><a href="#修订号（patch）" class="header-anchor">#</a> 修订号（patch）</h4> <h3 id="版本格式"><a href="#版本格式" class="header-anchor">#</a> 版本格式</h3> <h4 id="x-y-z"><a href="#x-y-z" class="header-anchor">#</a> x.y.z</h4> <p>表示精确版本号。任何其他版本号都不匹配，在一些比较重要的线上项目中，建议使用这种方式锁定版本</p> <h4 id="x-y-z-2"><a href="#x-y-z-2" class="header-anchor">#</a> ^x.y.z</h4> <p>表示兼容补丁和小版本更新的版本号。官方的定义是<code>能够兼容除了最左侧非0版本号之外的其他变化</code></p> <div class="language-text extra-class"><pre class="language-text"><code>&quot;^1.2.3&quot; 等价于 &quot;&gt;= 1.2.3 &lt; 2.0.0&quot;。即只要最左侧的 &quot;1&quot; 不变，其他都可以改变。所以 &quot;1.2.4&quot;, &quot;1.3.0&quot; 都可以兼容。

&quot;^0.2.3&quot; 等价于 &quot;&gt;= 0.2.3 &lt; 0.3.0&quot;。因为最左侧的是 &quot;0&quot;，那么只要第二位 &quot;2&quot; 不变，其他的都兼容，比如 &quot;0.2.4&quot; 和 &quot;0.2.99&quot;

&quot;^0.0.3&quot; 等价于 &quot;&gt;= 0.0.3 &lt; 0.0.4&quot;。这里最左侧的非 &quot;0&quot; 只有 &quot;3&quot;，且没有其他版本号了，所以这个也等价于精确的 &quot;0.0.3&quot;。
</code></pre></div><h4 id="x-y-z-3"><a href="#x-y-z-3" class="header-anchor">#</a> ~x.y.z</h4> <p>表示只兼容补丁更新的版本号。关于 ~ 的定义分为两部分：如果列出了小版本号（第二位），则只兼容补丁（第三位）的修改；如果没有列出小版本号，则兼容第二和第三位的修改</p> <div class="language-text extra-class"><pre class="language-text"><code>&quot;~1.2.3&quot; 列出了小版本号 &quot;2&quot;，因此只兼容第三位的修改，等价于 &quot;&gt;= 1.2.3 &lt; 1.3.0&quot;。

&quot;~1.2&quot; 也列出了小版本号，因此和上面一样兼容第三位的修改，等价于 &quot;&gt;= 1.2.0 &lt; 1.3.0&quot;。

&quot;~1&quot; 没有列出小版本号，可以兼容第二第三位的修改，因此等价于 &quot;&gt;= 1.0.0 &lt; 2.0.0&quot;
</code></pre></div><h4 id="x-y-z-beta-1"><a href="#x-y-z-beta-1" class="header-anchor">#</a> x.y.z-beta.1</h4> <p>带预发布关键词的版本号</p> <div class="language-text extra-class"><pre class="language-text"><code>alpha(α)：预览版，或者叫内部测试版；一般不向外部发布，会有很多bug；一般只有测试人员使用。

beta(β)：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在alpha版之后推出。

rc(release candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。
</code></pre></div><h3 id="npm-script"><a href="#npm-script" class="header-anchor">#</a> npm script</h3> <p>如果全局安装@vue/cli-service的话，@vue/cli-service源文件会被安装在全局源文件安装目录（/user/local/lib/node_modules）下，而npm会在全局可执行bin文件安装（/usr/local/bin）目录下创建一个指向../lib/node_modules/@vue/cli-service/bin/vue-cli-service.js文件的名为vue-cli-service的软链接，这样就可以直接在终端输入vue-cli-service来执行。</p> <p>如果局部安装@vue/cli-service的话，
npm则会在本地项目node_modules/.bin目录下创建一个指向../@vue/cli-service/bin/vue-cli-service.js名为vue-cli-service的软链接，
这个时候需要在终端中输入./node_modules/.bin/vue-cli-service来执行（也可以使用npx vue-cli-service命令来执行，
npx 的作用就是为了方便调用项目内部安装的模块）。</p> <h3 id="多命令运行"><a href="#多命令运行" class="header-anchor">#</a> 多命令运行</h3> <ul><li>&amp;&amp; 串行</li> <li>&amp; 并行</li></ul> <h3 id="oliver-steele的嵌套对象访问模式"><a href="#oliver-steele的嵌套对象访问模式" class="header-anchor">#</a> Oliver Steele的嵌套对象访问模式</h3> <p>const name = ((user || {}).personalInfo || {}).name;</p> <p>使用这种表示法，永远不会遇到无法读取未定义的属性“name”。做法是检查用户是否存在，如果不存在，就创建一个空对象，这样，下一个级别的键将始终从存在的对象访问。</p> <h3 id="如何让-a-1-a-2-a-3"><a href="#如何让-a-1-a-2-a-3" class="header-anchor">#</a> 如何让 <code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
   value<span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
   <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="new的实现原理"><a href="#new的实现原理" class="header-anchor">#</a> new的实现原理</h2> <p>原文: <a href="https://juejin.im/post/5d124a12f265da1b9163a28d?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener noreferrer">这儿有20道大厂面试题等你查收<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol><li>创建一个空对象，构造函数中的this指向这个空对象</li> <li>这个新对象被执行[[原型]]连接</li> <li>执行构造函数方法，属性和方法被添加到this引用的对象中</li> <li>如果构造函数中没有返回其它对象，那么返回this，即创造的这个的新对象，否则，返回构造函数中返回的对象</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 创造的新对象</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>constructor<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 第一个参数是构造函数</span>
  target<span class="token punctuation">.</span>___proto__ <span class="token operator">=</span> constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 执行[[原型]]连接；target是constructor的实例</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行构造函数，将属性或方法添加到创建的空对象上</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token comment">// 如果构造函数执行的结构返回的是一个对象，那么返回这个对象</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> target<span class="token punctuation">;</span> <span class="token comment">// 如果构造函数返回的不是一个对象，返回创建的新对象</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="为什么div里嵌套了img底部会有白块"><a href="#为什么div里嵌套了img底部会有白块" class="header-anchor">#</a> 为什么div里嵌套了img底部会有白块</h2> <p>因为img默认是按基线(baseline)对齐的。对比一下图片和右边的p, q, y等字母，你会发现这三个字母的“小尾巴”和图片下方的空白一样高。下面这张图中的黑线就是那条基线</p> <p><img src="data:image/png;base64,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" alt="img"></p> <p>要去掉空格可以使用vertical-align: bottom或将img标签变为块级元素</p> <h2 id="前后端鉴权"><a href="#前后端鉴权" class="header-anchor">#</a> 前后端鉴权</h2> <p>原文: <a href="https://blog.csdn.net/wang839305939/article/details/78713124/" target="_blank" rel="noopener noreferrer">前后端鉴权<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="http-basic-authentication"><a href="#http-basic-authentication" class="header-anchor">#</a> HTTP Basic Authentication</h3> <p>这种授权方式是浏览器遵守http协议实现的基本授权方式,HTTP协议进行通信的过程中，HTTP协议定义了基本认证认证允许HTTP服务器对客户端进行用户身份证的方法。</p> <ol><li><p>客户端向服务器请求数据，请求的内容可能是一个网页或者是一个ajax异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器:</p></li> <li><p>服务器向客户端发送验证请求代码401,（WWW-Authenticate: Basic realm=”google.com”这句话是关键，如果没有客户端不会弹出用户名和密码输入界面）</p> <div class="language-txt extra-class"><pre class="language-text"><code>HTTP/1.0 401 Unauthorised
  Server: SokEvo/1.0
  WWW-Authenticate: Basic realm=”google.com”
  Content-Type: text/html
  Content-Length: xxx
</code></pre></div></li> <li><p>当符合http1.0或1.1规范的客户端（如IE，FIREFOX）收到401返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。</p></li> <li><p>用户输入用户名和密码后，将用户名及密码以BASE64加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：</p> <div class="language-txt extra-class"><pre class="language-text"><code>Get /index.html HTTP/1.0
  Host:www.google.com
  Authorization: Basic d2FuZzp3YW5n
</code></pre></div></li> <li><p>服务器收到上述请求信息后，将Authorization字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端</p></li></ol> <p>通过上面的简单讲解 其实我们已经可以返现这种验证方式的缺陷加密方式简单，仅仅是base64加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。</p> <h3 id="session-cookie"><a href="#session-cookie" class="header-anchor">#</a> session-cookie</h3> <ol><li><p>服务器在接受客户端首次访问时在服务器端创建seesion，然后保存seesion(我们可以将seesion保存在内存中，也可以保存在redis中，推荐使用后者)，然后给这个session生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。</p></li> <li><p>签名。这一步只是对sid进行加密处理，服务端会根据这个secret密钥进行解密。（非必需步骤）</p></li> <li><p>浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求de 请求头中会带上该域名下的cookie信息，</p></li> <li><p>服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后判断该请求是否合法。</p></li></ol> <h3 id="token"><a href="#token" class="header-anchor">#</a> Token</h3> <ol><li><p>客户端使用用户名跟密码请求登录</p></li> <li><p>服务端收到请求，去验证用户名与密码</p></li> <li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p></li> <li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p></li> <li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p></li> <li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p></li></ol> <h4 id="与session-cookie区别"><a href="#与session-cookie区别" class="header-anchor">#</a> 与session-cookie区别</h4> <ol><li><p>sessionid 他只是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的seesion，这里面才保存着用户的登陆状态。但是token本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个token是否合法就行。</p></li> <li><p>session-cookie是需要cookie配合的，居然要cookie，那么在http代理客户端的选择上就是只有浏览器了，
因为只有浏览器才会去解析请求响应头里面的cookie,然后每次请求再默认带上该域名下的cookie。
但是我们知道http代理客户端不只有浏览器，还有原生APP等等，这个时候cookie是不起作用的，
或者浏览器端是可以禁止cookie的(虽然可以，但是这基本上是属于吃饱没事干的人干的事)…，但是token 就不一样，
他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，
可以把他存在本地的cookie,storage，或者内存中，然后再下一次请求的请求头重带上这个token就行了。简单点来说cookie-session机制他限制了客户端的类型，而token验证机制丰富了客户端类型。</p></li> <li><p>时效性。session-cookie的sessionid实在登陆的时候生成的而且在登出事时一直不变的，在一定程度上安全就会低，而token是可以在一段时间内动态改变的。</p></li> <li><p>可扩展性。token验证本身是比较灵活的，一是token的解决方案有许多，常用的是JWT,二来我们可以基于token验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。</p></li></ol> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <ul><li>Token 完全由应用管理，所以它可以避开同源策略. (Cookie是不允许垮域访问的,token不存在)</li> <li>Token 可以避免 CSRF 攻击(也是因为不需要cookie了)</li> <li>Token 可以是无状态的，可以在多个服务间共享</li> <li>Token 支持手机端访问(Cookie不支持手机端访问)</li> <li>服务器只需要对浏览器传来的token值进行解密，解密完成后进行用户数据的查询，如果查询成功，则通过认证.所以，即时有了多台服务器，服务器也只是做了token的解密和用户数据的查询，它不需要在服务端去保留用户的认证信息或者会话信息，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利，解决了session扩展性的弊端。</li></ul> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h4> <ul><li>占带宽: 正常情况下token要比 session_id更大，需要消耗更多流量，挤占更多带宽.(不过几乎可以忽略)</li> <li>性能问题: 相比于session-cookie来说，token需要服务端花费更多的时间和性能来对token进行解密验证.其实Token相比于session-cookie来说就是一个&quot;时间换空间&quot;的方案.</li></ul> <h4 id="jwt-json-web-token"><a href="#jwt-json-web-token" class="header-anchor">#</a> JWT(JSON WEB TOKEN)</h4> <p>JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成json对象，然后对这个对象进行某种方式的加密，返回给客户端，客户端在下次请求时带上这个token，服务端再收到请求时校验token合法性，其实也就是在校验请求的合法性。</p> <p>JWT对象通常由三部分构成:</p> <ol><li><p>Headers: 包括类别（typ）、加密算法（alg）</p></li> <li><p>Claims: 包括需要传递的用户信息</p></li> <li><p>Signature: 根据alg算法与私有秘钥进行加密得到的签名字串， 这一段是最重要的敏感信息，只能在服务端解密；</p></li></ol> <h3 id="oauth-开放授权"><a href="#oauth-开放授权" class="header-anchor">#</a> OAuth(开放授权)</h3> <h2 id="npm-参数问题"><a href="#npm-参数问题" class="header-anchor">#</a> npm 参数问题</h2> <p>在window系统中，类似<code>$npm_package_xxx</code>的变量是无法使用的，需要用<code>%npm_package_xxx%</code>形式代替</p> <p><a href="https://stackoverflow.com/questions/43705195/how-can-i-use-variables-in-package-json" target="_blank" rel="noopener noreferrer">stackoverflow中的解答<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="最后一行列表左对齐的n种方式"><a href="#最后一行列表左对齐的n种方式" class="header-anchor">#</a> 最后一行列表左对齐的N种方式</h2> <p>原文：<a href="https://www.zhangxinxu.com/wordpress/2019/08/css-flex-last-align/?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener noreferrer">让CSS flex布局最后一行列表左对齐的N种方法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol><li>Grid布局（注意兼容性）</li> <li>使用空白标签进行填充占位（容易理解，但引入无用标签）</li> <li>使用margin模拟space-between和间隙</li> <li>根据个数最后一个元素动态margin</li></ol> <h2 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h2> <p>主要思想是把运算过程尽量写成一些类嵌套的函数调用</p> <p>特点：</p> <ol><li><p>函数是“第一等公民”</p> <p>所谓“第一等公民”，指的是函数和其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p></li> <li><p>只用“表达式”，不用“语句”</p> <p>“表达式”是一个单纯的运算过程，总是有返回值；语句是执行某种惭怍，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p></li> <li><p>没有“副作用”</p> <p>所谓“副作用”，指的是函数内部与外部互动（最经典的情况，就是修改全局标量的值），产生运算以外的其他结果。</p> <p>函数式编程强调没有“副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p></li> <li><p>不修改状态</p> <p>函数式编程只是返回新的值，不修改系统变量</p></li> <li><p>引用透明</p> <p>引用透明指的是函数的运行不依赖外部变量或状态。只依赖输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</p></li></ol> <p>意义：</p> <ol><li><p>代码简洁，开发快速</p> <p>函数式编程大量使用函数，减少了代码的重复，因此程序变焦端，开发速度较快。</p></li> <li><p>接近自然语言，易于理解</p> <p>函数式编程的自由度很高，可以写出很接近自然语言的代码</p></li> <li><p>更方便的代码管理</p> <p>函数式编程不依赖、也不会改变外界状态，只要给定输出参数，返回的结果必定相同。因此每一个函数可以被看做独立单元，很有利于进行单元测试和除错，以及模块化组合。</p></li> <li><p>易于“并发编程”</p> <p>函数式编程不与要考虑“死锁”，因为它不修改变量，所以根本不存在“锁”线程的问题。</p></li> <li><p>代码的热升级</p> <p>函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。</p></li></ol> <h2 id="solid（面向对象设计）"><a href="#solid（面向对象设计）" class="header-anchor">#</a> SOLID（面向对象设计）</h2> <p>在程序设计领域，SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转），指代了面向对象编程和面向对象设计的五个基本原则</p> <table><thead><tr><th>首字母</th> <th>全称</th> <th>指代</th> <th>概念</th></tr></thead> <tbody><tr><td>S</td> <td>The Single Responsibility Principle</td> <td>单一功能原则</td> <td>认为对象应该仅具有一种单一功能的概念</td></tr> <tr><td>O</td> <td>The Open Closed Principle</td> <td>开闭原则</td> <td>认为软件应该是对于扩展开放的，但是对于修改封闭的概念</td></tr> <tr><td>L</td> <td>Liskov Substitution Principle</td> <td>里氏替换原则</td> <td>认为程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的概念</td></tr> <tr><td>I</td> <td>The Interface Segregation Principle</td> <td>接口隔离原则</td> <td>认为多个特定的客户端接口要好于一个宽泛用途的接口的概念</td></tr> <tr><td>D</td> <td>The Dependency Inversion Principle</td> <td>依赖反转原则</td> <td>认为一个方法应该遵从依赖于抽象而不是一个实例的概念，依赖注入是该原则的一种实现方式</td></tr></tbody></table> <!----></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/10/2020, 7:33:41 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.3c063390.js" defer></script><script src="/assets/js/2.bf5c3b7d.js" defer></script><script src="/assets/js/13.62002494.js" defer></script>
  </body>
</html>
